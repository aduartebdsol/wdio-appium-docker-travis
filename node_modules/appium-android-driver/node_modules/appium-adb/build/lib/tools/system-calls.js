"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "DEFAULT_ADB_EXEC_TIMEOUT", {
  enumerable: true,
  get: function () {
    return _helpers.DEFAULT_ADB_EXEC_TIMEOUT;
  }
});
exports.default = void 0;

require("source-map-support/register");

var _path = _interopRequireDefault(require("path"));

var _logger = _interopRequireDefault(require("../logger.js"));

var _bluebird = _interopRequireDefault(require("bluebird"));

var _appiumSupport = require("appium-support");

var _helpers = require("../helpers");

var _teen_process = require("teen_process");

var _asyncbox = require("asyncbox");

var _lodash = _interopRequireDefault(require("lodash"));

let systemCallMethods = {};
const DEFAULT_ADB_REBOOT_RETRIES = 90;
const LINKER_WARNING_REGEXP = /^WARNING: linker.+$/m;
const PROTOCOL_FAULT_ERROR_REGEXP = new RegExp('protocol fault \\(no status\\)', 'i');
const DEVICE_NOT_FOUND_ERROR_REGEXP = new RegExp(`error: device ('.+' )?not found`, 'i');
const DEVICE_CONNECTING_ERROR_REGEXP = new RegExp('error: device still connecting', 'i');
const CERTS_ROOT = '/system/etc/security/cacerts';

systemCallMethods.getSdkBinaryPath = async function getSdkBinaryPath(binaryName) {
  if (this.sdkRoot) {
    return await this.getBinaryFromSdkRoot(binaryName);
  }

  _logger.default.warn(`The ANDROID_HOME environment variable is not set to the Android SDK ` + `root directory path. ANDROID_HOME is required for compatibility ` + `with SDK 23+. Checking along PATH for ${binaryName}.`);

  return await this.getBinaryFromPath(binaryName);
};

systemCallMethods.getBinaryNameForOS = _lodash.default.memoize(function getBinaryNameForOS(binaryName) {
  if (!_appiumSupport.system.isWindows()) {
    return binaryName;
  }

  if (['android', 'apksigner', 'apkanalyzer'].includes(binaryName)) {
    return `${binaryName}.bat`;
  }

  if (!_path.default.extname(binaryName)) {
    return `${binaryName}.exe`;
  }

  return binaryName;
});

systemCallMethods.getBinaryFromSdkRoot = async function getBinaryFromSdkRoot(binaryName) {
  if (this.binaries[binaryName]) {
    return this.binaries[binaryName];
  }

  const fullBinaryName = this.getBinaryNameForOS(binaryName);
  const binaryLocs = ['platform-tools', 'emulator', 'tools', `tools${_path.default.sep}bin`].map(x => _path.default.resolve(this.sdkRoot, x, fullBinaryName));
  let buildToolsDirs = await (0, _helpers.getBuildToolsDirs)(this.sdkRoot);

  if (this.buildToolsVersion) {
    buildToolsDirs = buildToolsDirs.filter(x => _path.default.basename(x) === this.buildToolsVersion);

    if (_lodash.default.isEmpty(buildToolsDirs)) {
      _logger.default.info(`Found no build tools whose version matches to '${this.buildToolsVersion}'`);
    } else {
      _logger.default.info(`Using build tools at '${buildToolsDirs}'`);
    }
  }

  binaryLocs.push(..._lodash.default.flatten(buildToolsDirs.map(dir => [_path.default.resolve(dir, fullBinaryName), _path.default.resolve(dir, 'lib', fullBinaryName)])));
  let binaryLoc = null;

  for (const loc of binaryLocs) {
    if (await _appiumSupport.fs.exists(loc)) {
      binaryLoc = loc;
      break;
    }
  }

  if (_lodash.default.isNull(binaryLoc)) {
    throw new Error(`Could not find '${fullBinaryName}' in ${JSON.stringify(binaryLocs)}. ` + `Do you have Android Build Tools ${this.buildToolsVersion ? `v ${this.buildToolsVersion} ` : ''}` + `installed at '${this.sdkRoot}'?`);
  }

  _logger.default.info(`Using '${fullBinaryName}' from '${binaryLoc}'`);

  this.binaries[binaryName] = binaryLoc;
  return binaryLoc;
};

systemCallMethods.getBinaryFromPath = async function getBinaryFromPath(binaryName) {
  if (this.binaries[binaryName]) {
    return this.binaries[binaryName];
  }

  const fullBinaryName = this.getBinaryNameForOS(binaryName);

  try {
    const binaryLoc = await _appiumSupport.fs.which(fullBinaryName);

    _logger.default.info(`Using '${fullBinaryName}' from '${binaryLoc}'`);

    this.binaries[binaryName] = binaryLoc;
    return binaryLoc;
  } catch (e) {
    throw new Error(`Could not find '${fullBinaryName}' in PATH. Please set the ANDROID_HOME ` + `or ANDROID_SDK_ROOT environment variables to the correct Android SDK root directory path.`);
  }
};

systemCallMethods.getConnectedDevices = async function getConnectedDevices() {
  _logger.default.debug('Getting connected devices...');

  let stdout;

  try {
    ({
      stdout
    } = await (0, _teen_process.exec)(this.executable.path, [...this.executable.defaultArgs, 'devices']));
  } catch (e) {
    throw new Error(`Error while getting connected devices. Original error: ${e.message}`);
  }

  const listHeader = 'List of devices';
  const startingIndex = stdout.indexOf(listHeader);

  if (startingIndex < 0) {
    throw new Error(`Unexpected output while trying to get devices: ${stdout}`);
  }

  stdout = stdout.slice(startingIndex);
  let excludedLines = [listHeader, 'adb server', '* daemon'];

  if (!this.allowOfflineDevices) {
    excludedLines.push('offline');
  }

  const devices = stdout.split('\n').map(_lodash.default.trim).filter(line => line && !excludedLines.some(x => line.includes(x))).reduce((acc, line) => {
    const [udid, state] = line.split(/\s+/);
    acc.push({
      udid,
      state
    });
    return acc;
  }, []);

  if (_lodash.default.isEmpty(devices)) {
    _logger.default.debug('No connected devices have been detected');
  } else {
    _logger.default.debug(`Connected devices: ${JSON.stringify(devices)}`);
  }

  return devices;
};

systemCallMethods.getDevicesWithRetry = async function getDevicesWithRetry(timeoutMs = 20000) {
  const timer = new _appiumSupport.timing.Timer().start();

  _logger.default.debug('Trying to find a connected android device');

  const getDevices = async () => {
    if (timer.getDuration().asMilliSeconds > timeoutMs) {
      throw new Error(`Could not find a connected Android device in ${timer.getDuration().asMilliSeconds.toFixed(0)}ms.`);
    }

    try {
      const devices = await this.getConnectedDevices();

      if (devices.length > 0) {
        return devices;
      }
    } catch (ign) {}

    _logger.default.debug('Could not find devices, restarting adb server...');

    await this.restartAdb();
    await (0, _asyncbox.sleep)(200);
    return await getDevices();
  };

  return await getDevices();
};

systemCallMethods.restartAdb = async function restartAdb() {
  if (this.suppressKillServer) {
    _logger.default.debug(`Not restarting abd since 'suppressKillServer' is on`);

    return;
  }

  _logger.default.debug('Restarting adb');

  try {
    await this.killServer();
  } catch (e) {
    _logger.default.error(`Error killing ADB server, going to see if it's online anyway`);
  }
};

systemCallMethods.killServer = async function killServer() {
  _logger.default.debug(`Killing adb server on port '${this.adbPort}'`);

  await this.adbExec(['kill-server'], {
    exclusive: true
  });
};

systemCallMethods.resetTelnetAuthToken = _lodash.default.memoize(async function resetTelnetAuthToken() {
  const homeFolderPath = process.env[process.platform === 'win32' ? 'USERPROFILE' : 'HOME'];

  if (!homeFolderPath) {
    _logger.default.warn(`Cannot find the path to user home folder. Ignoring resetting of emulator's telnet authentication token`);

    return false;
  }

  const dstPath = _path.default.resolve(homeFolderPath, '.emulator_console_auth_token');

  _logger.default.debug(`Overriding ${dstPath} with an empty string to avoid telnet authentication for emulator commands`);

  try {
    await _appiumSupport.fs.writeFile(dstPath, '');
  } catch (e) {
    _logger.default.warn(`Error ${e.message} while resetting the content of ${dstPath}. Ignoring resetting of emulator's telnet authentication token`);

    return false;
  }

  return true;
});

systemCallMethods.adbExecEmu = async function adbExecEmu(cmd) {
  await this.verifyEmulatorConnected();
  await this.resetTelnetAuthToken();
  await this.adbExec(['emu', ...cmd]);
};

let isExecLocked = false;

systemCallMethods.adbExec = async function adbExec(cmd, opts = {}) {
  if (!cmd) {
    throw new Error('You need to pass in a command to adbExec()');
  }

  opts = _lodash.default.cloneDeep(opts);
  opts.timeout = opts.timeout || this.adbExecTimeout || _helpers.DEFAULT_ADB_EXEC_TIMEOUT;
  opts.timeoutCapName = opts.timeoutCapName || 'adbExecTimeout';
  cmd = _lodash.default.isArray(cmd) ? cmd : [cmd];
  let adbRetried = false;

  const execFunc = async () => {
    try {
      const args = [...this.executable.defaultArgs, ...cmd];

      _logger.default.debug(`Running '${this.executable.path} ${_appiumSupport.util.quote(args)}'`);

      let {
        stdout
      } = await (0, _teen_process.exec)(this.executable.path, args, opts);
      stdout = stdout.replace(LINKER_WARNING_REGEXP, '').trim();
      return stdout;
    } catch (e) {
      const errText = `${e.message}, ${e.stdout}, ${e.stderr}`;
      const protocolFaultError = PROTOCOL_FAULT_ERROR_REGEXP.test(errText);
      const deviceNotFoundError = DEVICE_NOT_FOUND_ERROR_REGEXP.test(errText);
      const deviceConnectingError = DEVICE_CONNECTING_ERROR_REGEXP.test(errText);

      if (protocolFaultError || deviceNotFoundError || deviceConnectingError) {
        _logger.default.info(`Error sending command, reconnecting device and retrying: ${cmd}`);

        await (0, _asyncbox.sleep)(1000);
        await this.getDevicesWithRetry();

        if (adbRetried) {
          adbRetried = true;
          return await execFunc();
        }
      }

      if (e.code === 0 && e.stdout) {
        return e.stdout.replace(LINKER_WARNING_REGEXP, '').trim();
      }

      if (_lodash.default.isNull(e.code)) {
        e.message = `Error executing adbExec. Original error: '${e.message}'. ` + `Try to increase the ${opts.timeout}ms adb execution timeout represented by '${opts.timeoutCapName}' capability`;
      } else {
        e.message = `Error executing adbExec. Original error: '${e.message}'; ` + `Stderr: '${(e.stderr || '').trim()}'; Code: '${e.code}'`;
      }

      throw e;
    }
  };

  if (isExecLocked) {
    _logger.default.debug('Waiting until the other exclusive ADB command is completed');

    await (0, _asyncbox.waitForCondition)(() => !isExecLocked, {
      waitMs: Number.MAX_SAFE_INTEGER,
      intervalMs: 10
    });

    _logger.default.debug('Continuing with the current ADB command');
  }

  if (opts.exclusive) {
    isExecLocked = true;
  }

  try {
    return await execFunc();
  } finally {
    if (opts.exclusive) {
      isExecLocked = false;
    }
  }
};

systemCallMethods.shell = async function shell(cmd, opts = {}) {
  const {
    privileged,
    keepPrivileged
  } = opts;
  let shouldRestoreUser = false;

  if (privileged) {
    _logger.default.info(`'adb shell ${cmd}' requires root access. Attempting to gain root access now.`);

    const {
      wasAlreadyRooted,
      isSuccessful
    } = await this.root();
    shouldRestoreUser = !wasAlreadyRooted;

    if (wasAlreadyRooted) {
      _logger.default.info('Device already had root access');
    } else {
      _logger.default.info(isSuccessful ? 'Root access successfully gained' : 'Could not gain root access');
    }
  }

  let didCommandFail = false;

  try {
    try {
      return await this.adbExec(_lodash.default.isArray(cmd) ? ['shell', ...cmd] : ['shell', cmd], opts);
    } catch (err) {
      didCommandFail = true;
      throw err;
    }
  } finally {
    if (privileged && shouldRestoreUser && (!keepPrivileged || didCommandFail)) {
      const {
        isSuccessful
      } = await this.unroot();

      _logger.default.debug(isSuccessful ? 'Returned device to unrooted state' : 'Could not return device to unrooted state');
    }
  }
};

systemCallMethods.createSubProcess = function createSubProcess(args = []) {
  args = this.executable.defaultArgs.concat(args);

  _logger.default.debug(`Creating ADB subprocess with args: ${JSON.stringify(args)}`);

  return new _teen_process.SubProcess(this.getAdbPath(), args);
};

systemCallMethods.getAdbServerPort = function getAdbServerPort() {
  return this.adbPort;
};

systemCallMethods.getEmulatorPort = async function getEmulatorPort() {
  _logger.default.debug('Getting running emulator port');

  if (this.emulatorPort !== null) {
    return this.emulatorPort;
  }

  try {
    let devices = await this.getConnectedDevices();
    let port = this.getPortFromEmulatorString(devices[0].udid);

    if (port) {
      return port;
    } else {
      throw new Error(`Emulator port not found`);
    }
  } catch (e) {
    throw new Error(`No devices connected. Original error: ${e.message}`);
  }
};

systemCallMethods.getPortFromEmulatorString = function getPortFromEmulatorString(emStr) {
  let portPattern = /emulator-(\d+)/;

  if (portPattern.test(emStr)) {
    return parseInt(portPattern.exec(emStr)[1], 10);
  }

  return false;
};

systemCallMethods.getConnectedEmulators = async function getConnectedEmulators() {
  _logger.default.debug('Getting connected emulators');

  try {
    let devices = await this.getConnectedDevices();
    let emulators = [];

    for (let device of devices) {
      let port = this.getPortFromEmulatorString(device.udid);

      if (port) {
        device.port = port;
        emulators.push(device);
      }
    }

    _logger.default.debug(`${_appiumSupport.util.pluralize('emulator', emulators.length, true)} connected`);

    return emulators;
  } catch (e) {
    throw new Error(`Error getting emulators. Original error: ${e.message}`);
  }
};

systemCallMethods.setEmulatorPort = function setEmulatorPort(emPort) {
  this.emulatorPort = emPort;
};

systemCallMethods.setDeviceId = function setDeviceId(deviceId) {
  _logger.default.debug(`Setting device id to ${deviceId}`);

  this.curDeviceId = deviceId;
  let argsHasDevice = this.executable.defaultArgs.indexOf('-s');

  if (argsHasDevice !== -1) {
    this.executable.defaultArgs.splice(argsHasDevice, 2);
  }

  this.executable.defaultArgs.push('-s', deviceId);
};

systemCallMethods.setDevice = function setDevice(deviceObj) {
  let deviceId = deviceObj.udid;
  let emPort = this.getPortFromEmulatorString(deviceId);
  this.setEmulatorPort(emPort);
  this.setDeviceId(deviceId);
};

systemCallMethods.getRunningAVD = async function getRunningAVD(avdName) {
  _logger.default.debug(`Trying to find '${avdName}' emulator`);

  try {
    const emulators = await this.getConnectedEmulators();

    for (const emulator of emulators) {
      this.setEmulatorPort(emulator.port);
      const runningAVDName = await this.sendTelnetCommand('avd name');

      if (_lodash.default.toLower(avdName) === _lodash.default.toLower(runningAVDName)) {
        _logger.default.debug(`Found emulator '${avdName}' on port ${emulator.port}`);

        this.setDeviceId(emulator.udid);
        return emulator;
      }
    }

    _logger.default.debug(`Emulator '${avdName}' not running`);

    return null;
  } catch (e) {
    throw new Error(`Error getting AVD. Original error: ${e.message}`);
  }
};

systemCallMethods.getRunningAVDWithRetry = async function getRunningAVDWithRetry(avdName, timeoutMs = 20000) {
  let runningAvd;

  try {
    await (0, _asyncbox.waitForCondition)(async () => {
      try {
        runningAvd = await this.getRunningAVD(avdName.replace('@', ''));
        return runningAvd;
      } catch (e) {
        _logger.default.debug(e.message);

        return false;
      }
    }, {
      waitMs: timeoutMs,
      intervalMs: 1000
    });
  } catch (e) {
    throw new Error(`Error getting AVD with retry. Original error: ${e.message}`);
  }

  return runningAvd;
};

systemCallMethods.killAllEmulators = async function killAllEmulators() {
  let cmd, args;

  if (_appiumSupport.system.isWindows()) {
    cmd = 'TASKKILL';
    args = ['TASKKILL', '/IM', 'emulator.exe'];
  } else {
    cmd = '/usr/bin/killall';
    args = ['-m', 'emulator*'];
  }

  try {
    await (0, _teen_process.exec)(cmd, args);
  } catch (e) {
    throw new Error(`Error killing emulators. Original error: ${e.message}`);
  }
};

systemCallMethods.killEmulator = async function killEmulator(avdName = null, timeout = 60000) {
  if (_appiumSupport.util.hasValue(avdName)) {
    _logger.default.debug(`Killing avd '${avdName}'`);

    const device = await this.getRunningAVD(avdName);

    if (!device) {
      _logger.default.info(`No avd with name '${avdName}' running. Skipping kill step.`);

      return false;
    }
  } else {
    _logger.default.debug(`Killing avd with id '${this.curDeviceId}'`);

    if (!(await this.isEmulatorConnected())) {
      _logger.default.debug(`Emulator with id '${this.curDeviceId}' not connected. Skipping kill step`);

      return false;
    }
  }

  await this.adbExec(['emu', 'kill']);

  _logger.default.debug(`Waiting up to ${timeout}ms until the emulator '${avdName ? avdName : this.curDeviceId}' is killed`);

  try {
    await (0, _asyncbox.waitForCondition)(async () => {
      try {
        return _appiumSupport.util.hasValue(avdName) ? !(await this.getRunningAVD(avdName)) : !(await this.isEmulatorConnected());
      } catch (ign) {}

      return false;
    }, {
      waitMs: timeout,
      intervalMs: 2000
    });
  } catch (e) {
    throw new Error(`The emulator '${avdName ? avdName : this.curDeviceId}' is still running after being killed ${timeout}ms ago`);
  }

  _logger.default.info(`Successfully killed the '${avdName ? avdName : this.curDeviceId}' emulator`);

  return true;
};

systemCallMethods.launchAVD = async function launchAVD(avdName, opts = {}) {
  const {
    args = [],
    env = {},
    language,
    country,
    launchTimeout = 60000,
    readyTimeout = 60000,
    retryTimes = 1
  } = opts;

  _logger.default.debug(`Launching Emulator with AVD ${avdName}, launchTimeout ` + `${launchTimeout}ms and readyTimeout ${readyTimeout}ms`);

  const emulatorBinaryPath = await this.getSdkBinaryPath('emulator');

  if (avdName[0] === '@') {
    avdName = avdName.substr(1);
  }

  await this.checkAvdExist(avdName);
  const launchArgs = ['-avd', avdName];
  launchArgs.push(...(0, _helpers.toAvdLocaleArgs)(language, country));

  if (!_lodash.default.isEmpty(args)) {
    launchArgs.push(...(_lodash.default.isArray(args) ? args : _appiumSupport.util.shellParse(`${args}`)));
  }

  _logger.default.debug(`Running '${emulatorBinaryPath}' with args: ${_appiumSupport.util.quote(launchArgs)}`);

  if (!_lodash.default.isEmpty(env)) {
    _logger.default.debug(`Customized emulator environment: ${JSON.stringify(env)}`);
  }

  const proc = new _teen_process.SubProcess(emulatorBinaryPath, launchArgs, {
    env: Object.assign({}, process.env, env)
  });
  await proc.start(0);
  proc.on('output', (stdout, stderr) => {
    for (let line of (stdout || stderr || '').split('\n').filter(Boolean)) {
      _logger.default.info(`[AVD OUTPUT] ${line}`);
    }
  });
  proc.on('die', (code, signal) => {
    _logger.default.warn(`Emulator avd ${avdName} exited with code ${code}${signal ? `, signal ${signal}` : ''}`);
  });
  await (0, _asyncbox.retry)(retryTimes, async () => await this.getRunningAVDWithRetry(avdName, launchTimeout));
  await this.waitForEmulatorReady(readyTimeout);
  return proc;
};

systemCallMethods.getAdbVersion = _lodash.default.memoize(async function getAdbVersion() {
  try {
    let adbVersion = (await this.adbExec('version')).replace(/Android\sDebug\sBridge\sversion\s([\d.]*)[\s\w-]*/, '$1');
    let parts = adbVersion.split('.');
    return {
      versionString: adbVersion,
      versionFloat: parseFloat(adbVersion),
      major: parseInt(parts[0], 10),
      minor: parseInt(parts[1], 10),
      patch: parts[2] ? parseInt(parts[2], 10) : undefined
    };
  } catch (e) {
    throw new Error(`Error getting adb version. Original error: '${e.message}'; ` + `Stderr: '${(e.stderr || '').trim()}'; Code: '${e.code}'`);
  }
});

systemCallMethods.checkAvdExist = async function checkAvdExist(avdName) {
  let cmd, result;

  try {
    cmd = await this.getSdkBinaryPath('emulator');
    result = await (0, _teen_process.exec)(cmd, ['-list-avds']);
  } catch (e) {
    let unknownOptionError = new RegExp('unknown option: -list-avds', 'i').test(e.stderr);

    if (!unknownOptionError) {
      throw new Error(`Error executing checkAvdExist. Original error: '${e.message}'; ` + `Stderr: '${(e.stderr || '').trim()}'; Code: '${e.code}'`);
    }

    const sdkVersion = await (0, _helpers.getSdkToolsVersion)();
    let binaryName = 'android';

    if (sdkVersion) {
      if (sdkVersion.major >= 25) {
        binaryName = 'avdmanager';
      }
    } else {
      _logger.default.warn(`Defaulting binary name to '${binaryName}', because SDK version cannot be parsed`);
    }

    cmd = await this.getSdkBinaryPath(binaryName);
    result = await (0, _teen_process.exec)(cmd, ['list', 'avd', '-c']);
  }

  if (result.stdout.indexOf(avdName) === -1) {
    let existings = `(${result.stdout.trim().replace(/[\n]/g, '), (')})`;
    throw new Error(`Avd '${avdName}' is not available. please select your avd name from one of these: '${existings}'`);
  }
};

systemCallMethods.waitForEmulatorReady = async function waitForEmulatorReady(timeoutMs = 20000) {
  try {
    await (0, _asyncbox.waitForCondition)(async () => {
      try {
        if (!(await this.shell(['getprop', 'init.svc.bootanim'])).includes('stopped')) {
          return false;
        }

        return /\d+\[\w+\]/.test(await this.shell(['pm', 'get-install-location']));
      } catch (err) {
        _logger.default.debug(`Waiting for emulator startup. Intermediate error: ${err.message}`);

        return false;
      }
    }, {
      waitMs: timeoutMs,
      intervalMs: 3000
    });
  } catch (e) {
    throw new Error(`Emulator is not ready within ${timeoutMs}ms`);
  }
};

systemCallMethods.waitForDevice = async function waitForDevice(appDeviceReadyTimeout = 30) {
  this.appDeviceReadyTimeout = appDeviceReadyTimeout;
  const retries = 3;
  const timeout = parseInt(this.appDeviceReadyTimeout, 10) / retries * 1000;
  await (0, _asyncbox.retry)(retries, async () => {
    try {
      await this.adbExec('wait-for-device', {
        timeout
      });
      await this.ping();
    } catch (e) {
      await this.restartAdb();
      await this.getConnectedDevices();
      throw new Error(`Error waiting for the device to be available. Original error: '${e.message}'`);
    }
  });
};

systemCallMethods.reboot = async function reboot(retries = DEFAULT_ADB_REBOOT_RETRIES) {
  const {
    wasAlreadyRooted
  } = await this.root();

  try {
    await this.shell(['stop']);
    await _bluebird.default.delay(2000);
    await this.setDeviceProperty('sys.boot_completed', 0, {
      privileged: false
    });
    await this.shell(['start']);
  } catch (e) {
    const {
      message
    } = e;

    if (message.includes('must be root')) {
      throw new Error(`Could not reboot device. Rebooting requires root access and ` + `attempt to get root access on device failed with error: '${message}'`);
    }

    throw e;
  } finally {
    if (!wasAlreadyRooted) {
      await this.unroot();
    }
  }

  const timer = new _appiumSupport.timing.Timer().start();
  await (0, _asyncbox.retryInterval)(retries, 1000, async () => {
    if ((await this.getDeviceProperty('sys.boot_completed')) === '1') {
      return;
    }

    const msg = `Reboot is not completed after ${timer.getDuration().asMilliSeconds.toFixed(0)}ms`;

    _logger.default.debug(msg);

    throw new Error(msg);
  });
};

systemCallMethods.changeUserPrivileges = async function changeUserPrivileges(isElevated) {
  const cmd = isElevated ? 'root' : 'unroot';
  const isRoot = await this.isRoot();

  if (isRoot && isElevated || !isRoot && !isElevated) {
    return {
      isSuccessful: true,
      wasAlreadyRooted: isRoot
    };
  }

  let wasAlreadyRooted = isRoot;

  try {
    let {
      stdout
    } = await this.adbExec([cmd]);

    if (stdout) {
      if (stdout.includes('adbd cannot run as root')) {
        return {
          isSuccessful: false,
          wasAlreadyRooted
        };
      }

      if (stdout.includes('already running as root')) {
        wasAlreadyRooted = true;
      }
    }

    return {
      isSuccessful: true,
      wasAlreadyRooted
    };
  } catch (err) {
    const {
      stderr = '',
      message
    } = err;

    _logger.default.warn(`Unable to ${cmd} adb daemon. Original error: '${message}'. Stderr: '${stderr}'. Continuing.`);

    if (['closed', 'device offline', 'timeout expired'].some(x => stderr.toLowerCase().includes(x))) {
      _logger.default.warn(`Attempt to 'adb ${cmd}' caused device to go offline. Restarting adb.`);

      await this.restartAdb();
    }

    return {
      isSuccessful: false,
      wasAlreadyRooted
    };
  }
};

systemCallMethods.root = async function root() {
  return await this.changeUserPrivileges(true);
};

systemCallMethods.unroot = async function unroot() {
  return await this.changeUserPrivileges(false);
};

systemCallMethods.isRoot = async function isRoot() {
  return (await this.shell(['whoami'])).trim() === 'root';
};

systemCallMethods.fileExists = async function fileExists(remotePath) {
  const passFlag = '__PASS__';
  const checkCmd = `[ -e '${remotePath.replace(/'/g, `\\'`)}' ] && echo ${passFlag}`;

  try {
    return _lodash.default.includes(await this.shell([checkCmd]), passFlag);
  } catch (ign) {
    return false;
  }
};

systemCallMethods.ls = async function ls(remotePath, opts = []) {
  try {
    let args = ['ls', ...opts, remotePath];
    let stdout = await this.shell(args);
    let lines = stdout.split('\n');
    return lines.map(l => l.trim()).filter(Boolean).filter(l => l.indexOf('No such file') === -1);
  } catch (err) {
    if (err.message.indexOf('No such file or directory') === -1) {
      throw err;
    }

    return [];
  }
};

systemCallMethods.fileSize = async function fileSize(remotePath) {
  try {
    const files = await this.ls(remotePath, ['-la']);

    if (files.length !== 1) {
      throw new Error(`Remote path is not a file`);
    }

    const match = /[rwxsStT\-+]{10}[\s\d]*\s[^\s]+\s+[^\s]+\s+(\d+)/.exec(files[0]);

    if (!match || _lodash.default.isNaN(parseInt(match[1], 10))) {
      throw new Error(`Unable to parse size from list output: '${files[0]}'`);
    }

    return parseInt(match[1], 10);
  } catch (err) {
    throw new Error(`Unable to get file size for '${remotePath}': ${err.message}`);
  }
};

systemCallMethods.installMitmCertificate = async function installMitmCertificate(cert) {
  const openSsl = await (0, _helpers.getOpenSslForOs)();

  if (!_lodash.default.isBuffer(cert)) {
    cert = Buffer.from(cert, 'base64');
  }

  const tmpRoot = await _appiumSupport.tempDir.openDir();

  try {
    const srcCert = _path.default.resolve(tmpRoot, 'source.cer');

    await _appiumSupport.fs.writeFile(srcCert, cert);
    let {
      stdout
    } = await (0, _teen_process.exec)(openSsl, ['x509', '-noout', '-hash', '-in', srcCert]);
    const certHash = stdout.trim();

    _logger.default.debug(`Got certificate hash: ${certHash}`);

    _logger.default.debug('Preparing certificate content');

    ({
      stdout
    } = await (0, _teen_process.exec)(openSsl, ['x509', '-in', srcCert], {
      isBuffer: true
    }));
    let dstCertContent = stdout;
    ({
      stdout
    } = await (0, _teen_process.exec)(openSsl, ['x509', '-in', srcCert, '-text', '-fingerprint', '-noout'], {
      isBuffer: true
    }));
    dstCertContent = Buffer.concat([dstCertContent, stdout]);

    const dstCert = _path.default.resolve(tmpRoot, `${certHash}.0`);

    await _appiumSupport.fs.writeFile(dstCert, dstCertContent);

    _logger.default.debug('Remounting /system in rw mode');

    await (0, _asyncbox.retryInterval)(5, 2000, async () => await this.adbExec(['remount']));

    _logger.default.debug(`Uploading the generated certificate from '${dstCert}' to '${CERTS_ROOT}'`);

    await this.push(dstCert, CERTS_ROOT);

    _logger.default.debug('Remounting /system to confirm changes');

    await this.adbExec(['remount']);
  } catch (err) {
    throw new Error(`Cannot inject the custom certificate. ` + `Is the certificate properly encoded into base64-string? ` + `Do you have root permissions on the device? ` + `Original error: ${err.message}`);
  } finally {
    await _appiumSupport.fs.rimraf(tmpRoot);
  }
};

systemCallMethods.isMitmCertificateInstalled = async function isMitmCertificateInstalled(cert) {
  const openSsl = await (0, _helpers.getOpenSslForOs)();

  if (!_lodash.default.isBuffer(cert)) {
    cert = Buffer.from(cert, 'base64');
  }

  const tmpRoot = await _appiumSupport.tempDir.openDir();
  let certHash;

  try {
    const tmpCert = _path.default.resolve(tmpRoot, 'source.cer');

    await _appiumSupport.fs.writeFile(tmpCert, cert);
    const {
      stdout
    } = await (0, _teen_process.exec)(openSsl, ['x509', '-noout', '-hash', '-in', tmpCert]);
    certHash = stdout.trim();
  } catch (err) {
    throw new Error(`Cannot retrieve the certificate hash. ` + `Is the certificate properly encoded into base64-string? ` + `Original error: ${err.message}`);
  } finally {
    await _appiumSupport.fs.rimraf(tmpRoot);
  }

  const dstPath = _path.default.posix.resolve(CERTS_ROOT, `${certHash}.0`);

  _logger.default.debug(`Checking if the certificate is already installed at '${dstPath}'`);

  return await this.fileExists(dstPath);
};

var _default = systemCallMethods;
exports.default = _default;require('source-map-support').install();


//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi90b29scy9zeXN0ZW0tY2FsbHMuanMiXSwibmFtZXMiOlsic3lzdGVtQ2FsbE1ldGhvZHMiLCJERUZBVUxUX0FEQl9SRUJPT1RfUkVUUklFUyIsIkxJTktFUl9XQVJOSU5HX1JFR0VYUCIsIlBST1RPQ09MX0ZBVUxUX0VSUk9SX1JFR0VYUCIsIlJlZ0V4cCIsIkRFVklDRV9OT1RfRk9VTkRfRVJST1JfUkVHRVhQIiwiREVWSUNFX0NPTk5FQ1RJTkdfRVJST1JfUkVHRVhQIiwiQ0VSVFNfUk9PVCIsImdldFNka0JpbmFyeVBhdGgiLCJiaW5hcnlOYW1lIiwic2RrUm9vdCIsImdldEJpbmFyeUZyb21TZGtSb290IiwibG9nIiwid2FybiIsImdldEJpbmFyeUZyb21QYXRoIiwiZ2V0QmluYXJ5TmFtZUZvck9TIiwiXyIsIm1lbW9pemUiLCJzeXN0ZW0iLCJpc1dpbmRvd3MiLCJpbmNsdWRlcyIsInBhdGgiLCJleHRuYW1lIiwiYmluYXJpZXMiLCJmdWxsQmluYXJ5TmFtZSIsImJpbmFyeUxvY3MiLCJzZXAiLCJtYXAiLCJ4IiwicmVzb2x2ZSIsImJ1aWxkVG9vbHNEaXJzIiwiYnVpbGRUb29sc1ZlcnNpb24iLCJmaWx0ZXIiLCJiYXNlbmFtZSIsImlzRW1wdHkiLCJpbmZvIiwicHVzaCIsImZsYXR0ZW4iLCJkaXIiLCJiaW5hcnlMb2MiLCJsb2MiLCJmcyIsImV4aXN0cyIsImlzTnVsbCIsIkVycm9yIiwiSlNPTiIsInN0cmluZ2lmeSIsIndoaWNoIiwiZSIsImdldENvbm5lY3RlZERldmljZXMiLCJkZWJ1ZyIsInN0ZG91dCIsImV4ZWN1dGFibGUiLCJkZWZhdWx0QXJncyIsIm1lc3NhZ2UiLCJsaXN0SGVhZGVyIiwic3RhcnRpbmdJbmRleCIsImluZGV4T2YiLCJzbGljZSIsImV4Y2x1ZGVkTGluZXMiLCJhbGxvd09mZmxpbmVEZXZpY2VzIiwiZGV2aWNlcyIsInNwbGl0IiwidHJpbSIsImxpbmUiLCJzb21lIiwicmVkdWNlIiwiYWNjIiwidWRpZCIsInN0YXRlIiwiZ2V0RGV2aWNlc1dpdGhSZXRyeSIsInRpbWVvdXRNcyIsInRpbWVyIiwidGltaW5nIiwiVGltZXIiLCJzdGFydCIsImdldERldmljZXMiLCJnZXREdXJhdGlvbiIsImFzTWlsbGlTZWNvbmRzIiwidG9GaXhlZCIsImxlbmd0aCIsImlnbiIsInJlc3RhcnRBZGIiLCJzdXBwcmVzc0tpbGxTZXJ2ZXIiLCJraWxsU2VydmVyIiwiZXJyb3IiLCJhZGJQb3J0IiwiYWRiRXhlYyIsImV4Y2x1c2l2ZSIsInJlc2V0VGVsbmV0QXV0aFRva2VuIiwiaG9tZUZvbGRlclBhdGgiLCJwcm9jZXNzIiwiZW52IiwicGxhdGZvcm0iLCJkc3RQYXRoIiwid3JpdGVGaWxlIiwiYWRiRXhlY0VtdSIsImNtZCIsInZlcmlmeUVtdWxhdG9yQ29ubmVjdGVkIiwiaXNFeGVjTG9ja2VkIiwib3B0cyIsImNsb25lRGVlcCIsInRpbWVvdXQiLCJhZGJFeGVjVGltZW91dCIsIkRFRkFVTFRfQURCX0VYRUNfVElNRU9VVCIsInRpbWVvdXRDYXBOYW1lIiwiaXNBcnJheSIsImFkYlJldHJpZWQiLCJleGVjRnVuYyIsImFyZ3MiLCJ1dGlsIiwicXVvdGUiLCJyZXBsYWNlIiwiZXJyVGV4dCIsInN0ZGVyciIsInByb3RvY29sRmF1bHRFcnJvciIsInRlc3QiLCJkZXZpY2VOb3RGb3VuZEVycm9yIiwiZGV2aWNlQ29ubmVjdGluZ0Vycm9yIiwiY29kZSIsIndhaXRNcyIsIk51bWJlciIsIk1BWF9TQUZFX0lOVEVHRVIiLCJpbnRlcnZhbE1zIiwic2hlbGwiLCJwcml2aWxlZ2VkIiwia2VlcFByaXZpbGVnZWQiLCJzaG91bGRSZXN0b3JlVXNlciIsIndhc0FscmVhZHlSb290ZWQiLCJpc1N1Y2Nlc3NmdWwiLCJyb290IiwiZGlkQ29tbWFuZEZhaWwiLCJlcnIiLCJ1bnJvb3QiLCJjcmVhdGVTdWJQcm9jZXNzIiwiY29uY2F0IiwiU3ViUHJvY2VzcyIsImdldEFkYlBhdGgiLCJnZXRBZGJTZXJ2ZXJQb3J0IiwiZ2V0RW11bGF0b3JQb3J0IiwiZW11bGF0b3JQb3J0IiwicG9ydCIsImdldFBvcnRGcm9tRW11bGF0b3JTdHJpbmciLCJlbVN0ciIsInBvcnRQYXR0ZXJuIiwicGFyc2VJbnQiLCJleGVjIiwiZ2V0Q29ubmVjdGVkRW11bGF0b3JzIiwiZW11bGF0b3JzIiwiZGV2aWNlIiwicGx1cmFsaXplIiwic2V0RW11bGF0b3JQb3J0IiwiZW1Qb3J0Iiwic2V0RGV2aWNlSWQiLCJkZXZpY2VJZCIsImN1ckRldmljZUlkIiwiYXJnc0hhc0RldmljZSIsInNwbGljZSIsInNldERldmljZSIsImRldmljZU9iaiIsImdldFJ1bm5pbmdBVkQiLCJhdmROYW1lIiwiZW11bGF0b3IiLCJydW5uaW5nQVZETmFtZSIsInNlbmRUZWxuZXRDb21tYW5kIiwidG9Mb3dlciIsImdldFJ1bm5pbmdBVkRXaXRoUmV0cnkiLCJydW5uaW5nQXZkIiwia2lsbEFsbEVtdWxhdG9ycyIsImtpbGxFbXVsYXRvciIsImhhc1ZhbHVlIiwiaXNFbXVsYXRvckNvbm5lY3RlZCIsImxhdW5jaEFWRCIsImxhbmd1YWdlIiwiY291bnRyeSIsImxhdW5jaFRpbWVvdXQiLCJyZWFkeVRpbWVvdXQiLCJyZXRyeVRpbWVzIiwiZW11bGF0b3JCaW5hcnlQYXRoIiwic3Vic3RyIiwiY2hlY2tBdmRFeGlzdCIsImxhdW5jaEFyZ3MiLCJzaGVsbFBhcnNlIiwicHJvYyIsIk9iamVjdCIsImFzc2lnbiIsIm9uIiwiQm9vbGVhbiIsInNpZ25hbCIsIndhaXRGb3JFbXVsYXRvclJlYWR5IiwiZ2V0QWRiVmVyc2lvbiIsImFkYlZlcnNpb24iLCJwYXJ0cyIsInZlcnNpb25TdHJpbmciLCJ2ZXJzaW9uRmxvYXQiLCJwYXJzZUZsb2F0IiwibWFqb3IiLCJtaW5vciIsInBhdGNoIiwidW5kZWZpbmVkIiwicmVzdWx0IiwidW5rbm93bk9wdGlvbkVycm9yIiwic2RrVmVyc2lvbiIsImV4aXN0aW5ncyIsIndhaXRGb3JEZXZpY2UiLCJhcHBEZXZpY2VSZWFkeVRpbWVvdXQiLCJyZXRyaWVzIiwicGluZyIsInJlYm9vdCIsIkIiLCJkZWxheSIsInNldERldmljZVByb3BlcnR5IiwiZ2V0RGV2aWNlUHJvcGVydHkiLCJtc2ciLCJjaGFuZ2VVc2VyUHJpdmlsZWdlcyIsImlzRWxldmF0ZWQiLCJpc1Jvb3QiLCJ0b0xvd2VyQ2FzZSIsImZpbGVFeGlzdHMiLCJyZW1vdGVQYXRoIiwicGFzc0ZsYWciLCJjaGVja0NtZCIsImxzIiwibGluZXMiLCJsIiwiZmlsZVNpemUiLCJmaWxlcyIsIm1hdGNoIiwiaXNOYU4iLCJpbnN0YWxsTWl0bUNlcnRpZmljYXRlIiwiY2VydCIsIm9wZW5Tc2wiLCJpc0J1ZmZlciIsIkJ1ZmZlciIsImZyb20iLCJ0bXBSb290IiwidGVtcERpciIsIm9wZW5EaXIiLCJzcmNDZXJ0IiwiY2VydEhhc2giLCJkc3RDZXJ0Q29udGVudCIsImRzdENlcnQiLCJyaW1yYWYiLCJpc01pdG1DZXJ0aWZpY2F0ZUluc3RhbGxlZCIsInRtcENlcnQiLCJwb3NpeCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFJQTs7QUFDQTs7QUFDQTs7QUFHQSxJQUFJQSxpQkFBaUIsR0FBRyxFQUF4QjtBQUVBLE1BQU1DLDBCQUEwQixHQUFHLEVBQW5DO0FBRUEsTUFBTUMscUJBQXFCLEdBQUcsc0JBQTlCO0FBQ0EsTUFBTUMsMkJBQTJCLEdBQUcsSUFBSUMsTUFBSixDQUFXLGdDQUFYLEVBQTZDLEdBQTdDLENBQXBDO0FBQ0EsTUFBTUMsNkJBQTZCLEdBQUcsSUFBSUQsTUFBSixDQUFZLGlDQUFaLEVBQThDLEdBQTlDLENBQXRDO0FBQ0EsTUFBTUUsOEJBQThCLEdBQUcsSUFBSUYsTUFBSixDQUFXLGdDQUFYLEVBQTZDLEdBQTdDLENBQXZDO0FBRUEsTUFBTUcsVUFBVSxHQUFHLDhCQUFuQjs7QUFRQVAsaUJBQWlCLENBQUNRLGdCQUFsQixHQUFxQyxlQUFlQSxnQkFBZixDQUFpQ0MsVUFBakMsRUFBNkM7QUFDaEYsTUFBSSxLQUFL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QUFDQSxNQUFJRSxRQUFKOztBQUNBLE1BQUk7QUFDRixVQUFNSyxPQUFPLEdBQUcvTixjQUFLUSxPQUFMLENBQWE4TSxPQUFiLEVBQXNCLFlBQXRCLENBQWhCOztBQUNBLFVBQU1sTSxrQkFBR3NELFNBQUgsQ0FBYXFKLE9BQWIsRUFBc0JkLElBQXRCLENBQU47QUFDQSxVQUFNO0FBQUNuTCxNQUFBQTtBQUFELFFBQVcsTUFBTSx3QkFBS29MLE9BQUwsRUFBYyxDQUFDLE1BQUQsRUFBUyxRQUFULEVBQW1CLE9BQW5CLEVBQTRCLEtBQTVCLEVBQW1DYSxPQUFuQyxDQUFkLENBQXZCO0FBQ0FMLElBQUFBLFFBQVEsR0FBRzVMLE1BQU0sQ0FBQ1ksSUFBUCxFQUFYO0FBQ0QsR0FMRCxDQUtFLE9BQU9xRSxHQUFQLEVBQVk7QUFDWixVQUFNLElBQUl4RixLQUFKLENBQVcsd0NBQUQsR0FDQywwREFERCxHQUVDLG1CQUFrQndGLEdBQUcsQ0FBQzlFLE9BQVEsRUFGekMsQ0FBTjtBQUdELEdBVEQsU0FTVTtBQUNSLFVBQU1iLGtCQUFHeU0sTUFBSCxDQUFVUCxPQUFWLENBQU47QUFDRDs7QUFDRCxRQUFNN0ksT0FBTyxHQUFHekUsY0FBS2dPLEtBQUwsQ0FBV3hOLE9BQVgsQ0FBbUJ0QixVQUFuQixFQUFnQyxHQUFFd08sUUFBUyxJQUEzQyxDQUFoQjs7QUFDQW5PLGtCQUFJc0MsS0FBSixDQUFXLHdEQUF1RDRDLE9BQVEsR0FBMUU7O0FBQ0EsU0FBTyxNQUFNLEtBQUs0SCxVQUFMLENBQWdCNUgsT0FBaEIsQ0FBYjtBQUNELENBeEJEOztlQTBCZTlGLGlCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgbG9nIGZyb20gJy4uL2xvZ2dlci5qcyc7XG5pbXBvcnQgQiBmcm9tICdibHVlYmlyZCc7XG5pbXBvcnQgeyBzeXN0ZW0sIGZzLCB1dGlsLCB0ZW1wRGlyLCB0aW1pbmcgfSBmcm9tICdhcHBpdW0tc3VwcG9ydCc7XG5pbXBvcnQge1xuICBnZXRTZGtUb29sc1ZlcnNpb24sIGdldEJ1aWxkVG9vbHNEaXJzLCB0b0F2ZExvY2FsZUFyZ3MsXG4gIGdldE9wZW5Tc2xGb3JPcywgREVGQVVMVF9BREJfRVhFQ19USU1FT1VUXG59IGZyb20gJy4uL2hlbHBlcnMnO1xuaW1wb3J0IHsgZXhlYywgU3ViUHJvY2VzcyB9IGZyb20gJ3RlZW5fcHJvY2Vzcyc7XG5pbXBvcnQgeyBzbGVlcCwgcmV0cnksIHJldHJ5SW50ZXJ2YWwsIHdhaXRGb3JDb25kaXRpb24gfSBmcm9tICdhc3luY2JveCc7XG5pbXBvcnQgXyBmcm9tICdsb2Rhc2gnO1xuXG5cbmxldCBzeXN0ZW1DYWxsTWV0aG9kcyA9IHt9O1xuXG5jb25zdCBERUZBVUxUX0FEQl9SRUJPT1RfUkVUUklFUyA9IDkwO1xuXG5jb25zdCBMSU5LRVJfV0FSTklOR19SRUdFWFAgPSAvXldBUk5JTkc6IGxpbmtlci4rJC9tO1xuY29uc3QgUFJPVE9DT0xfRkFVTFRfRVJST1JfUkVHRVhQID0gbmV3IFJlZ0V4cCgncHJvdG9jb2wgZmF1bHQgXFxcXChubyBzdGF0dXNcXFxcKScsICdpJyk7XG5jb25zdCBERVZJQ0VfTk9UX0ZPVU5EX0VSUk9SX1JFR0VYUCA9IG5ldyBSZWdFeHAoYGVycm9yOiBkZXZpY2UgKCcuKycgKT9ub3QgZm91bmRgLCAnaScpO1xuY29uc3QgREVWSUNFX0NPTk5FQ1RJTkdfRVJST1JfUkVHRVhQID0gbmV3IFJlZ0V4cCgnZXJyb3I6IGRldmljZSBzdGlsbCBjb25uZWN0aW5nJywgJ2knKTtcblxuY29uc3QgQ0VSVFNfUk9PVCA9ICcvc3lzdGVtL2V0Yy9zZWN1cml0eS9jYWNlcnRzJztcblxuLyoqXG4gKiBSZXRyaWV2ZSBmdWxsIHBhdGggdG8gdGhlIGdpdmVuIGJpbmFyeS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYmluYXJ5TmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBiaW5hcnkuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IEZ1bGwgcGF0aCB0byB0aGUgZ2l2ZW4gYmluYXJ5IGluY2x1ZGluZyBjdXJyZW50IFNESyByb290LlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5nZXRTZGtCaW5hcnlQYXRoID0gYXN5bmMgZnVuY3Rpb24gZ2V0U2RrQmluYXJ5UGF0aCAoYmluYXJ5TmFtZSkge1xuICBpZiAodGhpcy5zZGtSb290KSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuZ2V0QmluYXJ5RnJvbVNka1Jvb3QoYmluYXJ5TmFtZSk7XG4gIH1cbiAgbG9nLndhcm4oYFRoZSBBTkRST0lEX0hPTUUgZW52aXJvbm1lbnQgdmFyaWFibGUgaXMgbm90IHNldCB0byB0aGUgQW5kcm9pZCBTREsgYCArXG4gICAgYHJvb3QgZGlyZWN0b3J5IHBhdGguIEFORFJPSURfSE9NRSBpcyByZXF1aXJlZCBmb3IgY29tcGF0aWJpbGl0eSBgICtcbiAgICBgd2l0aCBTREsgMjMrLiBDaGVja2luZyBhbG9uZyBQQVRIIGZvciAke2JpbmFyeU5hbWV9LmApO1xuICByZXR1cm4gYXdhaXQgdGhpcy5nZXRCaW5hcnlGcm9tUGF0aChiaW5hcnlOYW1lKTtcbn07XG5cbi8qKlxuICogUmV0cmlldmUgZnVsbCBiaW5hcnkgbmFtZSBmb3IgdGhlIGN1cnJlbnQgb3BlcmF0aW5nIHN5c3RlbS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYmluYXJ5TmFtZSAtIHNpbXBsZSBiaW5hcnkgbmFtZSwgZm9yIGV4YW1wbGUgJ2FuZHJvaWQnLlxuICogQHJldHVybiB7c3RyaW5nfSBGb3JtYXR0ZWQgYmluYXJ5IG5hbWUgZGVwZW5kaW5nIG9uIHRoZSBjdXJyZW50IHBsYXRmb3JtLFxuICogICAgICAgICAgICAgICAgICBmb3IgZXhhbXBsZSwgJ2FuZHJvaWQuYmF0JyBvbiBXaW5kb3dzLlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5nZXRCaW5hcnlOYW1lRm9yT1MgPSBfLm1lbW9pemUoZnVuY3Rpb24gZ2V0QmluYXJ5TmFtZUZvck9TIChiaW5hcnlOYW1lKSB7XG4gIGlmICghc3lzdGVtLmlzV2luZG93cygpKSB7XG4gICAgcmV0dXJuIGJpbmFyeU5hbWU7XG4gIH1cblxuICBpZiAoWydhbmRyb2lkJywgJ2Fwa3NpZ25lcicsICdhcGthbmFseXplciddLmluY2x1ZGVzKGJpbmFyeU5hbWUpKSB7XG4gICAgcmV0dXJuIGAke2JpbmFyeU5hbWV9LmJhdGA7XG4gIH1cbiAgaWYgKCFwYXRoLmV4dG5hbWUoYmluYXJ5TmFtZSkpIHtcbiAgICByZXR1cm4gYCR7YmluYXJ5TmFtZX0uZXhlYDtcbiAgfVxuICByZXR1cm4gYmluYXJ5TmFtZTtcbn0pO1xuXG4vKipcbiAqIFJldHJpZXZlIGZ1bGwgcGF0aCB0byB0aGUgZ2l2ZW4gYmluYXJ5IGFuZCBjYWNoZXMgaXQgaW50byBgYmluYXJpZXNgXG4gKiBwcm9wZXJ0eSBvZiB0aGUgY3VycmVudCBBREIgaW5zdGFuY2UuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGJpbmFyeU5hbWUgLSBTaW1wbGUgbmFtZSBvZiBhIGJpbmFyeSBmaWxlLlxuICogQHJldHVybiB7c3RyaW5nfSBGdWxsIHBhdGggdG8gdGhlIGdpdmVuIGJpbmFyeS4gVGhlIG1ldGhvZCB0cmllc1xuICogICAgICAgICAgICAgICAgICB0byBlbnVtZXJhdGUgYWxsIHRoZSBrbm93biBsb2NhdGlvbnMgd2hlcmUgdGhlIGJpbmFyeVxuICogICAgICAgICAgICAgICAgICBtaWdodCBiZSBsb2NhdGVkIGFuZCBzdG9wcyB0aGUgc2VhcmNoIGFzIHNvb24gYXMgdGhlIGZpcnN0XG4gKiAgICAgICAgICAgICAgICAgIG1hdGNoIGlzIGZvdW5kIG9uIHRoZSBsb2NhbCBmaWxlIHN5c3RlbS5cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgYmluYXJ5IHdpdGggZ2l2ZW4gbmFtZSBpcyBub3QgcHJlc2VudCBhdCBhbnlcbiAqICAgICAgICAgICAgICAgICBvZiBrbm93biBsb2NhdGlvbnMgb3IgQW5kcm9pZCBTREsgaXMgbm90IGluc3RhbGxlZCBvbiB0aGVcbiAqICAgICAgICAgICAgICAgICBsb2NhbCBmaWxlIHN5c3RlbS5cbiAqL1xuc3lzdGVtQ2FsbE1ldGhvZHMuZ2V0QmluYXJ5RnJvbVNka1Jvb3QgPSBhc3luYyBmdW5jdGlvbiBnZXRCaW5hcnlGcm9tU2RrUm9vdCAoYmluYXJ5TmFtZSkge1xuICBpZiAodGhpcy5iaW5hcmllc1tiaW5hcnlOYW1lXSkge1xuICAgIHJldHVybiB0aGlzLmJpbmFyaWVzW2JpbmFyeU5hbWVdO1xuICB9XG5cbiAgY29uc3QgZnVsbEJpbmFyeU5hbWUgPSB0aGlzLmdldEJpbmFyeU5hbWVGb3JPUyhiaW5hcnlOYW1lKTtcbiAgY29uc3QgYmluYXJ5TG9jcyA9IFsncGxhdGZvcm0tdG9vbHMnLCAnZW11bGF0b3InLCAndG9vbHMnLCBgdG9vbHMke3BhdGguc2VwfWJpbmBdXG4gICAgLm1hcCgoeCkgPT4gcGF0aC5yZXNvbHZlKHRoaXMuc2RrUm9vdCwgeCwgZnVsbEJpbmFyeU5hbWUpKTtcbiAgLy8gZ2V0IHN1YnBhdGhzIGZvciBjdXJyZW50bHkgaW5zdGFsbGVkIGJ1aWxkIHRvb2wgZGlyZWN0b3JpZXNcbiAgbGV0IGJ1aWxkVG9vbHNEaXJzID0gYXdhaXQgZ2V0QnVpbGRUb29sc0RpcnModGhpcy5zZGtSb290KTtcbiAgaWYgKHRoaXMuYnVpbGRUb29sc1ZlcnNpb24pIHtcbiAgICBidWlsZFRvb2xzRGlycyA9IGJ1aWxkVG9vbHNEaXJzXG4gICAgICAuZmlsdGVyKCh4KSA9PiBwYXRoLmJhc2VuYW1lKHgpID09PSB0aGlzLmJ1aWxkVG9vbHNWZXJzaW9uKTtcbiAgICBpZiAoXy5pc0VtcHR5KGJ1aWxkVG9vbHNEaXJzKSkge1xuICAgICAgbG9nLmluZm8oYEZvdW5kIG5vIGJ1aWxkIHRvb2xzIHdob3NlIHZlcnNpb24gbWF0Y2hlcyB0byAnJHt0aGlzLmJ1aWxkVG9vbHNWZXJzaW9ufSdgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbG9nLmluZm8oYFVzaW5nIGJ1aWxkIHRvb2xzIGF0ICcke2J1aWxkVG9vbHNEaXJzfSdgKTtcbiAgICB9XG4gIH1cbiAgYmluYXJ5TG9jcy5wdXNoKC4uLihfLmZsYXR0ZW4oYnVpbGRUb29sc0RpcnNcbiAgICAubWFwKChkaXIpID0+IFtcbiAgICAgIHBhdGgucmVzb2x2ZShkaXIsIGZ1bGxCaW5hcnlOYW1lKSxcbiAgICAgIHBhdGgucmVzb2x2ZShkaXIsICdsaWInLCBmdWxsQmluYXJ5TmFtZSksXG4gICAgXSkpXG4gICkpO1xuXG4gIGxldCBiaW5hcnlMb2MgPSBudWxsO1xuICBmb3IgKGNvbnN0IGxvYyBvZiBiaW5hcnlMb2NzKSB7XG4gICAgaWYgKGF3YWl0IGZzLmV4aXN0cyhsb2MpKSB7XG4gICAgICBiaW5hcnlMb2MgPSBsb2M7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgaWYgKF8uaXNOdWxsKGJpbmFyeUxvYykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCBmaW5kICcke2Z1bGxCaW5hcnlOYW1lfScgaW4gJHtKU09OLnN0cmluZ2lmeShiaW5hcnlMb2NzKX0uIGAgK1xuICAgICAgYERvIHlvdSBoYXZlIEFuZHJvaWQgQnVpbGQgVG9vbHMgJHt0aGlzLmJ1aWxkVG9vbHNWZXJzaW9uID8gYHYgJHt0aGlzLmJ1aWxkVG9vbHNWZXJzaW9ufSBgIDogJyd9YCArXG4gICAgICBgaW5zdGFsbGVkIGF0ICcke3RoaXMuc2RrUm9vdH0nP2ApO1xuICB9XG4gIGxvZy5pbmZvKGBVc2luZyAnJHtmdWxsQmluYXJ5TmFtZX0nIGZyb20gJyR7YmluYXJ5TG9jfSdgKTtcbiAgdGhpcy5iaW5hcmllc1tiaW5hcnlOYW1lXSA9IGJpbmFyeUxvYztcbiAgcmV0dXJuIGJpbmFyeUxvYztcbn07XG5cbi8qKlxuICogUmV0cmlldmUgZnVsbCBwYXRoIHRvIGEgYmluYXJ5IGZpbGUgdXNpbmcgdGhlIHN0YW5kYXJkIHN5c3RlbSBsb29rdXAgdG9vbC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYmluYXJ5TmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBiaW5hcnkuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IEZ1bGwgcGF0aCB0byB0aGUgYmluYXJ5IHJlY2VpdmVkIGZyb20gJ3doaWNoJy8nd2hlcmUnXG4gKiAgICAgICAgICAgICAgICAgIG91dHB1dC5cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiBsb29rdXAgdG9vbCByZXR1cm5zIG5vbi16ZXJvIHJldHVybiBjb2RlLlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5nZXRCaW5hcnlGcm9tUGF0aCA9IGFzeW5jIGZ1bmN0aW9uIGdldEJpbmFyeUZyb21QYXRoIChiaW5hcnlOYW1lKSB7XG4gIGlmICh0aGlzLmJpbmFyaWVzW2JpbmFyeU5hbWVdKSB7XG4gICAgcmV0dXJuIHRoaXMuYmluYXJpZXNbYmluYXJ5TmFtZV07XG4gIH1cblxuICBjb25zdCBmdWxsQmluYXJ5TmFtZSA9IHRoaXMuZ2V0QmluYXJ5TmFtZUZvck9TKGJpbmFyeU5hbWUpO1xuICB0cnkge1xuICAgIGNvbnN0IGJpbmFyeUxvYyA9IGF3YWl0IGZzLndoaWNoKGZ1bGxCaW5hcnlOYW1lKTtcbiAgICBsb2cuaW5mbyhgVXNpbmcgJyR7ZnVsbEJpbmFyeU5hbWV9JyBmcm9tICcke2JpbmFyeUxvY30nYCk7XG4gICAgdGhpcy5iaW5hcmllc1tiaW5hcnlOYW1lXSA9IGJpbmFyeUxvYztcbiAgICByZXR1cm4gYmluYXJ5TG9jO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgZmluZCAnJHtmdWxsQmluYXJ5TmFtZX0nIGluIFBBVEguIFBsZWFzZSBzZXQgdGhlIEFORFJPSURfSE9NRSBgICtcbiAgICAgIGBvciBBTkRST0lEX1NES19ST09UIGVudmlyb25tZW50IHZhcmlhYmxlcyB0byB0aGUgY29ycmVjdCBBbmRyb2lkIFNESyByb290IGRpcmVjdG9yeSBwYXRoLmApO1xuICB9XG59O1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IERldmljZVxuICogQHByb3BlcnR5IHtzdHJpbmd9IHVkaWQgLSBUaGUgZGV2aWNlIHVkaWQuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gc3RhdGUgLSBDdXJyZW50IGRldmljZSBzdGF0ZSwgYXMgaXQgaXMgdmlzaWJsZSBpblxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgX2FkYiBkZXZpY2VzIC1sXyBvdXRwdXQuXG4gKi9cblxuLyoqXG4gKiBSZXRyaWV2ZSB0aGUgbGlzdCBvZiBkZXZpY2VzIHZpc2libGUgdG8gYWRiLlxuICpcbiAqIEByZXR1cm4ge0FycmF5LjxEZXZpY2U+fSBUaGUgbGlzdCBvZiBkZXZpY2VzIG9yIGFuIGVtcHR5IGxpc3QgaWZcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICBubyBkZXZpY2VzIGFyZSBjb25uZWN0ZWQuXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlcmUgd2FzIGFuIGVycm9yIHdoaWxlIGxpc3RpbmcgZGV2aWNlcy5cbiAqL1xuc3lzdGVtQ2FsbE1ldGhvZHMuZ2V0Q29ubmVjdGVkRGV2aWNlcyA9IGFzeW5jIGZ1bmN0aW9uIGdldENvbm5lY3RlZERldmljZXMgKCkge1xuICBsb2cuZGVidWcoJ0dldHRpbmcgY29ubmVjdGVkIGRldmljZXMuLi4nKTtcbiAgbGV0IHN0ZG91dDtcbiAgdHJ5IHtcbiAgICAoe3N0ZG91dH0gPSBhd2FpdCBleGVjKHRoaXMuZXhlY3V0YWJsZS5wYXRoLCBbLi4udGhpcy5leGVjdXRhYmxlLmRlZmF1bHRBcmdzLCAnZGV2aWNlcyddKSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm9yIHdoaWxlIGdldHRpbmcgY29ubmVjdGVkIGRldmljZXMuIE9yaWdpbmFsIGVycm9yOiAke2UubWVzc2FnZX1gKTtcbiAgfVxuICBjb25zdCBsaXN0SGVhZGVyID0gJ0xpc3Qgb2YgZGV2aWNlcyc7XG4gIC8vIGV4cGVjdGluZyBhZGIgZGV2aWNlcyB0byByZXR1cm4gb3V0cHV0IGFzXG4gIC8vIExpc3Qgb2YgZGV2aWNlcyBhdHRhY2hlZFxuICAvLyBlbXVsYXRvci01NTU0XHRkZXZpY2VcbiAgY29uc3Qgc3RhcnRpbmdJbmRleCA9IHN0ZG91dC5pbmRleE9mKGxpc3RIZWFkZXIpO1xuICBpZiAoc3RhcnRpbmdJbmRleCA8IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgb3V0cHV0IHdoaWxlIHRyeWluZyB0byBnZXQgZGV2aWNlczogJHtzdGRvdXR9YCk7XG4gIH1cbiAgLy8gc2xpY2luZyBvdXRwdXQgd2UgY2FyZSBhYm91dFxuICBzdGRvdXQgPSBzdGRvdXQuc2xpY2Uoc3RhcnRpbmdJbmRleCk7XG4gIGxldCBleGNsdWRlZExpbmVzID0gW2xpc3RIZWFkZXIsICdhZGIgc2VydmVyJywgJyogZGFlbW9uJ107XG4gIGlmICghdGhpcy5hbGxvd09mZmxpbmVEZXZpY2VzKSB7XG4gICAgZXhjbHVkZWRMaW5lcy5wdXNoKCdvZmZsaW5lJyk7XG4gIH1cbiAgY29uc3QgZGV2aWNlcyA9IHN0ZG91dC5zcGxpdCgnXFxuJylcbiAgICAubWFwKF8udHJpbSlcbiAgICAuZmlsdGVyKChsaW5lKSA9PiBsaW5lICYmICFleGNsdWRlZExpbmVzLnNvbWUoKHgpID0+IGxpbmUuaW5jbHVkZXMoeCkpKVxuICAgIC5yZWR1Y2UoKGFjYywgbGluZSkgPT4ge1xuICAgICAgLy8gc3RhdGUgaXMgXCJkZXZpY2VcIiwgYWZhaWNcbiAgICAgIGNvbnN0IFt1ZGlkLCBzdGF0ZV0gPSBsaW5lLnNwbGl0KC9cXHMrLyk7XG4gICAgICBhY2MucHVzaCh7dWRpZCwgc3RhdGV9KTtcbiAgICAgIHJldHVybiBhY2M7XG4gICAgfSwgW10pO1xuICBpZiAoXy5pc0VtcHR5KGRldmljZXMpKSB7XG4gICAgbG9nLmRlYnVnKCdObyBjb25uZWN0ZWQgZGV2aWNlcyBoYXZlIGJlZW4gZGV0ZWN0ZWQnKTtcbiAgfSBlbHNlIHtcbiAgICBsb2cuZGVidWcoYENvbm5lY3RlZCBkZXZpY2VzOiAke0pTT04uc3RyaW5naWZ5KGRldmljZXMpfWApO1xuICB9XG4gIHJldHVybiBkZXZpY2VzO1xufTtcblxuLyoqXG4gKiBSZXRyaWV2ZSB0aGUgbGlzdCBvZiBkZXZpY2VzIHZpc2libGUgdG8gYWRiIHdpdGhpbiB0aGUgZ2l2ZW4gdGltZW91dC5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gdGltZW91dE1zIC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byBnZXQgYXQgbGVhc3RcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbmUgbGlzdCBpdGVtLlxuICogQHJldHVybiB7QXJyYXkuPERldmljZT59IFRoZSBsaXN0IG9mIGNvbm5lY3RlZCBkZXZpY2VzLlxuICogQHRocm93cyB7RXJyb3J9IElmIG5vIGNvbm5lY3RlZCBkZXZpY2VzIGNhbiBiZSBkZXRlY3RlZCB3aXRoaW4gdGhlIGdpdmVuIHRpbWVvdXQuXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLmdldERldmljZXNXaXRoUmV0cnkgPSBhc3luYyBmdW5jdGlvbiBnZXREZXZpY2VzV2l0aFJldHJ5ICh0aW1lb3V0TXMgPSAyMDAwMCkge1xuICBjb25zdCB0aW1lciA9IG5ldyB0aW1pbmcuVGltZXIoKS5zdGFydCgpO1xuICBsb2cuZGVidWcoJ1RyeWluZyB0byBmaW5kIGEgY29ubmVjdGVkIGFuZHJvaWQgZGV2aWNlJyk7XG4gIGNvbnN0IGdldERldmljZXMgPSBhc3luYyAoKSA9PiB7XG4gICAgaWYgKHRpbWVyLmdldER1cmF0aW9uKCkuYXNNaWxsaVNlY29uZHMgPiB0aW1lb3V0TXMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IGZpbmQgYSBjb25uZWN0ZWQgQW5kcm9pZCBkZXZpY2UgaW4gJHt0aW1lci5nZXREdXJhdGlvbigpLmFzTWlsbGlTZWNvbmRzLnRvRml4ZWQoMCl9bXMuYCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBjb25zdCBkZXZpY2VzID0gYXdhaXQgdGhpcy5nZXRDb25uZWN0ZWREZXZpY2VzKCk7XG4gICAgICBpZiAoZGV2aWNlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJldHVybiBkZXZpY2VzO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGlnbikge31cblxuICAgIGxvZy5kZWJ1ZygnQ291bGQgbm90IGZpbmQgZGV2aWNlcywgcmVzdGFydGluZyBhZGIgc2VydmVyLi4uJyk7XG4gICAgYXdhaXQgdGhpcy5yZXN0YXJ0QWRiKCk7XG4gICAgLy8gY29vbCBkb3duXG4gICAgYXdhaXQgc2xlZXAoMjAwKTtcbiAgICByZXR1cm4gYXdhaXQgZ2V0RGV2aWNlcygpO1xuICB9O1xuICByZXR1cm4gYXdhaXQgZ2V0RGV2aWNlcygpO1xufTtcblxuLyoqXG4gKiBSZXN0YXJ0IGFkYiBzZXJ2ZXIsIHVubGVzcyBfdGhpcy5zdXBwcmVzc0tpbGxTZXJ2ZXJfIHByb3BlcnR5IGlzIHRydWUuXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLnJlc3RhcnRBZGIgPSBhc3luYyBmdW5jdGlvbiByZXN0YXJ0QWRiICgpIHtcbiAgaWYgKHRoaXMuc3VwcHJlc3NLaWxsU2VydmVyKSB7XG4gICAgbG9nLmRlYnVnKGBOb3QgcmVzdGFydGluZyBhYmQgc2luY2UgJ3N1cHByZXNzS2lsbFNlcnZlcicgaXMgb25gKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBsb2cuZGVidWcoJ1Jlc3RhcnRpbmcgYWRiJyk7XG4gIHRyeSB7XG4gICAgYXdhaXQgdGhpcy5raWxsU2VydmVyKCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBsb2cuZXJyb3IoYEVycm9yIGtpbGxpbmcgQURCIHNlcnZlciwgZ29pbmcgdG8gc2VlIGlmIGl0J3Mgb25saW5lIGFueXdheWApO1xuICB9XG59O1xuXG4vKipcbiAqIEtpbGwgYWRiIHNlcnZlci5cbiAqL1xuc3lzdGVtQ2FsbE1ldGhvZHMua2lsbFNlcnZlciA9IGFzeW5jIGZ1bmN0aW9uIGtpbGxTZXJ2ZXIgKCkge1xuICBsb2cuZGVidWcoYEtpbGxpbmcgYWRiIHNlcnZlciBvbiBwb3J0ICcke3RoaXMuYWRiUG9ydH0nYCk7XG4gIGF3YWl0IHRoaXMuYWRiRXhlYyhbJ2tpbGwtc2VydmVyJ10sIHtcbiAgICBleGNsdXNpdmU6IHRydWUsXG4gIH0pO1xufTtcblxuLyoqXG4gKiBSZXNldCBUZWxuZXQgYXV0aGVudGljYXRpb24gdG9rZW4uXG4gKiBAc2VlIHtAbGluayBodHRwOi8vdG9vbHMuYW5kcm9pZC5jb20vcmVjZW50L2VtdWxhdG9yMjUxNnJlbGVhc2Vub3Rlc30gZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gSWYgdG9rZW4gcmVzZXQgd2FzIHN1Y2Nlc3NmdWwuXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLnJlc2V0VGVsbmV0QXV0aFRva2VuID0gXy5tZW1vaXplKGFzeW5jIGZ1bmN0aW9uIHJlc2V0VGVsbmV0QXV0aFRva2VuICgpIHtcbiAgLy8gVGhlIG1ldGhvZHMgaXMgdXNlZCB0byByZW1vdmUgdGVsbmV0IGF1dGggdG9rZW5cbiAgLy9cbiAgY29uc3QgaG9tZUZvbGRlclBhdGggPSBwcm9jZXNzLmVudlsocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJykgPyAnVVNFUlBST0ZJTEUnIDogJ0hPTUUnXTtcbiAgaWYgKCFob21lRm9sZGVyUGF0aCkge1xuICAgIGxvZy53YXJuKGBDYW5ub3QgZmluZCB0aGUgcGF0aCB0byB1c2VyIGhvbWUgZm9sZGVyLiBJZ25vcmluZyByZXNldHRpbmcgb2YgZW11bGF0b3IncyB0ZWxuZXQgYXV0aGVudGljYXRpb24gdG9rZW5gKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgZHN0UGF0aCA9IHBhdGgucmVzb2x2ZShob21lRm9sZGVyUGF0aCwgJy5lbXVsYXRvcl9jb25zb2xlX2F1dGhfdG9rZW4nKTtcbiAgbG9nLmRlYnVnKGBPdmVycmlkaW5nICR7ZHN0UGF0aH0gd2l0aCBhbiBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgdGVsbmV0IGF1dGhlbnRpY2F0aW9uIGZvciBlbXVsYXRvciBjb21tYW5kc2ApO1xuICB0cnkge1xuICAgIGF3YWl0IGZzLndyaXRlRmlsZShkc3RQYXRoLCAnJyk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBsb2cud2FybihgRXJyb3IgJHtlLm1lc3NhZ2V9IHdoaWxlIHJlc2V0dGluZyB0aGUgY29udGVudCBvZiAke2RzdFBhdGh9LiBJZ25vcmluZyByZXNldHRpbmcgb2YgZW11bGF0b3IncyB0ZWxuZXQgYXV0aGVudGljYXRpb24gdG9rZW5gKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59KTtcblxuLyoqXG4gKiBFeGVjdXRlIHRoZSBnaXZlbiBlbXVsYXRvciBjb21tYW5kIHVzaW5nIF9hZGIgZW11XyB0b29sLlxuICpcbiAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz59IGNtZCAtIFRoZSBhcnJheSBvZiByZXN0IGNvbW1hbmQgbGluZSBwYXJhbWV0ZXJzLlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5hZGJFeGVjRW11ID0gYXN5bmMgZnVuY3Rpb24gYWRiRXhlY0VtdSAoY21kKSB7XG4gIGF3YWl0IHRoaXMudmVyaWZ5RW11bGF0b3JDb25uZWN0ZWQoKTtcbiAgYXdhaXQgdGhpcy5yZXNldFRlbG5ldEF1dGhUb2tlbigpO1xuICBhd2FpdCB0aGlzLmFkYkV4ZWMoWydlbXUnLCAuLi5jbWRdKTtcbn07XG5cbmxldCBpc0V4ZWNMb2NrZWQgPSBmYWxzZTtcblxuLyoqXG4gKiBFeGVjdXRlIHRoZSBnaXZlbiBhZGIgY29tbWFuZC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fSBjbWQgLSBUaGUgYXJyYXkgb2YgcmVzdCBjb21tYW5kIGxpbmUgcGFyYW1ldGVyc1xuICogICAgICAgICAgICAgICAgICAgICAgb3IgYSBzaW5nbGUgc3RyaW5nIHBhcmFtZXRlci5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gQWRkaXRpb25hbCBvcHRpb25zIG1hcHBpbmcuIFNlZVxuICogICAgICAgICAgICAgICAgICAgICAgICB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2FwcGl1bS9ub2RlLXRlZW5fcHJvY2Vzc31cbiAqICAgICAgICAgICAgICAgICAgICAgICAgZm9yIG1vcmUgZGV0YWlscy5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgWW91IGNhbiBhbHNvIHNldCB0aGUgYWRkaXRpb25hbCBgZXhjbHVzaXZlYCBwYXJhbVxuICogICAgICAgICAgICAgICAgICAgICAgICB0byBgdHJ1ZWAgdGhhdCBhc3N1cmVzIG5vIG90aGVyIHBhcmFsbGVsIGFkYiBjb21tYW5kc1xuICogICAgICAgICAgICAgICAgICAgICAgICBhcmUgZ29pbmcgdG8gYmUgZXhlY3V0ZWQgd2hpbGUgdGhlIGN1cnJlbnQgb25lIGlzIHJ1bm5pbmdcbiAqIEByZXR1cm4ge3N0cmluZ30gLSBDb21tYW5kJ3Mgc3Rkb3V0LlxuICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBjb21tYW5kIHJldHVybmVkIG5vbi16ZXJvIGV4aXQgY29kZS5cbiAqL1xuc3lzdGVtQ2FsbE1ldGhvZHMuYWRiRXhlYyA9IGFzeW5jIGZ1bmN0aW9uIGFkYkV4ZWMgKGNtZCwgb3B0cyA9IHt9KSB7XG4gIGlmICghY21kKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgbmVlZCB0byBwYXNzIGluIGEgY29tbWFuZCB0byBhZGJFeGVjKCknKTtcbiAgfVxuXG4gIG9wdHMgPSBfLmNsb25lRGVlcChvcHRzKTtcbiAgLy8gc2V0dGluZyBkZWZhdWx0IHRpbWVvdXQgZm9yIGVhY2ggY29tbWFuZCB0byBwcmV2ZW50IGluZmluaXRlIHdhaXQuXG4gIG9wdHMudGltZW91dCA9IG9wdHMudGltZW91dCB8fCB0aGlzLmFkYkV4ZWNUaW1lb3V0IHx8IERFRkFVTFRfQURCX0VYRUNfVElNRU9VVDtcbiAgb3B0cy50aW1lb3V0Q2FwTmFtZSA9IG9wdHMudGltZW91dENhcE5hbWUgfHwgJ2FkYkV4ZWNUaW1lb3V0JzsgLy8gRm9yIGVycm9yIG1lc3NhZ2VcblxuICBjbWQgPSBfLmlzQXJyYXkoY21kKSA/IGNtZCA6IFtjbWRdO1xuICBsZXQgYWRiUmV0cmllZCA9IGZhbHNlO1xuICBjb25zdCBleGVjRnVuYyA9IGFzeW5jICgpID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgYXJncyA9IFsuLi50aGlzLmV4ZWN1dGFibGUuZGVmYXVsdEFyZ3MsIC4uLmNtZF07XG4gICAgICBsb2cuZGVidWcoYFJ1bm5pbmcgJyR7dGhpcy5leGVjdXRhYmxlLnBhdGh9ICR7dXRpbC5xdW90ZShhcmdzKX0nYCk7XG4gICAgICBsZXQge3N0ZG91dH0gPSBhd2FpdCBleGVjKHRoaXMuZXhlY3V0YWJsZS5wYXRoLCBhcmdzLCBvcHRzKTtcbiAgICAgIC8vIHNvbWV0aW1lcyBBREIgcHJpbnRzIG91dCB3ZWlyZCBzdGRvdXQgd2FybmluZ3MgdGhhdCB3ZSBkb24ndCB3YW50XG4gICAgICAvLyB0byBpbmNsdWRlIGluIGFueSBvZiB0aGUgcmVzcG9uc2UgZGF0YSwgc28gbGV0J3Mgc3RyaXAgaXQgb3V0XG4gICAgICBzdGRvdXQgPSBzdGRvdXQucmVwbGFjZShMSU5LRVJfV0FSTklOR19SRUdFWFAsICcnKS50cmltKCk7XG4gICAgICByZXR1cm4gc3Rkb3V0O1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnN0IGVyclRleHQgPSBgJHtlLm1lc3NhZ2V9LCAke2Uuc3Rkb3V0fSwgJHtlLnN0ZGVycn1gO1xuICAgICAgY29uc3QgcHJvdG9jb2xGYXVsdEVycm9yID0gUFJPVE9DT0xfRkFVTFRfRVJST1JfUkVHRVhQLnRlc3QoZXJyVGV4dCk7XG4gICAgICBjb25zdCBkZXZpY2VOb3RGb3VuZEVycm9yID0gREVWSUNFX05PVF9GT1VORF9FUlJPUl9SRUdFWFAudGVzdChlcnJUZXh0KTtcbiAgICAgIGNvbnN0IGRldmljZUNvbm5lY3RpbmdFcnJvciA9IERFVklDRV9DT05ORUNUSU5HX0VSUk9SX1JFR0VYUC50ZXN0KGVyclRleHQpO1xuICAgICAgaWYgKHByb3RvY29sRmF1bHRFcnJvciB8fCBkZXZpY2VOb3RGb3VuZEVycm9yIHx8IGRldmljZUNvbm5lY3RpbmdFcnJvcikge1xuICAgICAgICBsb2cuaW5mbyhgRXJyb3Igc2VuZGluZyBjb21tYW5kLCByZWNvbm5lY3RpbmcgZGV2aWNlIGFuZCByZXRyeWluZzogJHtjbWR9YCk7XG4gICAgICAgIGF3YWl0IHNsZWVwKDEwMDApO1xuICAgICAgICBhd2FpdCB0aGlzLmdldERldmljZXNXaXRoUmV0cnkoKTtcblxuICAgICAgICAvLyB0cnkgYWdhaW4gb25lIHRpbWVcbiAgICAgICAgaWYgKGFkYlJldHJpZWQpIHtcbiAgICAgICAgICBhZGJSZXRyaWVkID0gdHJ1ZTtcbiAgICAgICAgICByZXR1cm4gYXdhaXQgZXhlY0Z1bmMoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZS5jb2RlID09PSAwICYmIGUuc3Rkb3V0KSB7XG4gICAgICAgIHJldHVybiBlLnN0ZG91dC5yZXBsYWNlKExJTktFUl9XQVJOSU5HX1JFR0VYUCwgJycpLnRyaW0oKTtcbiAgICAgIH1cblxuICAgICAgaWYgKF8uaXNOdWxsKGUuY29kZSkpIHtcbiAgICAgICAgZS5tZXNzYWdlID0gYEVycm9yIGV4ZWN1dGluZyBhZGJFeGVjLiBPcmlnaW5hbCBlcnJvcjogJyR7ZS5tZXNzYWdlfScuIGAgK1xuICAgICAgICAgIGBUcnkgdG8gaW5jcmVhc2UgdGhlICR7b3B0cy50aW1lb3V0fW1zIGFkYiBleGVjdXRpb24gdGltZW91dCByZXByZXNlbnRlZCBieSAnJHtvcHRzLnRpbWVvdXRDYXBOYW1lfScgY2FwYWJpbGl0eWA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlLm1lc3NhZ2UgPSBgRXJyb3IgZXhlY3V0aW5nIGFkYkV4ZWMuIE9yaWdpbmFsIGVycm9yOiAnJHtlLm1lc3NhZ2V9JzsgYCArXG4gICAgICAgICAgYFN0ZGVycjogJyR7KGUuc3RkZXJyIHx8ICcnKS50cmltKCl9JzsgQ29kZTogJyR7ZS5jb2RlfSdgO1xuICAgICAgfVxuICAgICAgdGhyb3cgZTtcbiAgICB9XG4gIH07XG5cbiAgaWYgKGlzRXhlY0xvY2tlZCkge1xuICAgIGxvZy5kZWJ1ZygnV2FpdGluZyB1bnRpbCB0aGUgb3RoZXIgZXhjbHVzaXZlIEFEQiBjb21tYW5kIGlzIGNvbXBsZXRlZCcpO1xuICAgIGF3YWl0IHdhaXRGb3JDb25kaXRpb24oKCkgPT4gIWlzRXhlY0xvY2tlZCwge1xuICAgICAgd2FpdE1zOiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUixcbiAgICAgIGludGVydmFsTXM6IDEwLFxuICAgIH0pO1xuICAgIGxvZy5kZWJ1ZygnQ29udGludWluZyB3aXRoIHRoZSBjdXJyZW50IEFEQiBjb21tYW5kJyk7XG4gIH1cbiAgaWYgKG9wdHMuZXhjbHVzaXZlKSB7XG4gICAgaXNFeGVjTG9ja2VkID0gdHJ1ZTtcbiAgfVxuICB0cnkge1xuICAgIHJldHVybiBhd2FpdCBleGVjRnVuYygpO1xuICB9IGZpbmFsbHkge1xuICAgIGlmIChvcHRzLmV4Y2x1c2l2ZSkge1xuICAgICAgaXNFeGVjTG9ja2VkID0gZmFsc2U7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFNoZWxsRXhlY09wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7P3N0cmluZ30gdGltZW91dENhcE5hbWUgW2FkYkV4ZWNUaW1lb3V0XSAtIHRoZSBuYW1lIG9mIHRoZSBjb3JyZXNwb25kaW5nIEFwcGl1bSdzIHRpbWVvdXQgY2FwYWJpbGl0eVxuICogKHVzZWQgaW4gdGhlIGVycm9yIG1lc3NhZ2VzKS5cbiAqIEBwcm9wZXJ0eSB7P251bWJlcn0gdGltZW91dCBbYWRiRXhlY1RpbWVvdXRdIC0gY29tbWFuZCBleGVjdXRpb24gdGltZW91dC5cbiAqIEBwcm9wZXJ0eSB7P2Jvb2xlYW59IHByaXZpbGVnZWQgW2ZhbHN5XSAtIFdoZXRoZXIgdG8gcnVuIHRoZSBnaXZlbiBjb21tYW5kIGFzIHJvb3QuXG4gKiBAcHJvcGVydHkgez9ib29sZWFufSBrZWVwUHJpdmlsZWdlZCBbZmFsc3ldIC0gV2hldGhlciB0byBrZWVwIHJvb3QgbW9kZSBhZnRlciBjb21tYW5kIGV4ZWN1dGlvbiBpcyBjb21wbGV0ZWQuXG4gKlxuICogQWxsIG90aGVyIHByb3BlcnRpZXMgYXJlIHRoZSBzYW1lIGFzIGZvciBgZXhlY2AgY2FsbCBmcm9tIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vYXBwaXVtL25vZGUtdGVlbl9wcm9jZXNzfVxuICogbW9kdWxlXG4gKi9cblxuLyoqXG4gKiBFeGVjdXRlIHRoZSBnaXZlbiBjb21tYW5kIHVzaW5nIF9hZGIgc2hlbGxfIHByZWZpeC5cbiAqXG4gKiBAcGFyYW0geyFBcnJheS48c3RyaW5nPnxzdHJpbmd9IGNtZCAtIFRoZSBhcnJheSBvZiByZXN0IGNvbW1hbmQgbGluZSBwYXJhbWV0ZXJzIG9yIGEgc2luZ2xlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyaW5nIHBhcmFtZXRlci5cbiAqIEBwYXJhbSB7P1NoZWxsRXhlY09wdGlvbnN9IG9wdHMgW3t9XSAtIEFkZGl0aW9uYWwgb3B0aW9ucyBtYXBwaW5nLlxuICogQHJldHVybiB7c3RyaW5nfSAtIENvbW1hbmQncyBzdGRvdXQuXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIGNvbW1hbmQgcmV0dXJuZWQgbm9uLXplcm8gZXhpdCBjb2RlLlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5zaGVsbCA9IGFzeW5jIGZ1bmN0aW9uIHNoZWxsIChjbWQsIG9wdHMgPSB7fSkge1xuICBjb25zdCB7XG4gICAgcHJpdmlsZWdlZCxcbiAgICBrZWVwUHJpdmlsZWdlZCxcbiAgfSA9IG9wdHM7XG5cbiAgLy8gSWYgdGhlIGNvbW1hbmQgcmVxdWlyZXMgcHJpdmlsZWdlcywgcm9vdCB0aGlzIGRldmljZVxuICBsZXQgc2hvdWxkUmVzdG9yZVVzZXIgPSBmYWxzZTtcbiAgaWYgKHByaXZpbGVnZWQpIHtcbiAgICBsb2cuaW5mbyhgJ2FkYiBzaGVsbCAke2NtZH0nIHJlcXVpcmVzIHJvb3QgYWNjZXNzLiBBdHRlbXB0aW5nIHRvIGdhaW4gcm9vdCBhY2Nlc3Mgbm93LmApO1xuICAgIGNvbnN0IHt3YXNBbHJlYWR5Um9vdGVkLCBpc1N1Y2Nlc3NmdWx9ID0gYXdhaXQgdGhpcy5yb290KCk7XG4gICAgc2hvdWxkUmVzdG9yZVVzZXIgPSAhd2FzQWxyZWFkeVJvb3RlZDtcbiAgICBpZiAod2FzQWxyZWFkeVJvb3RlZCkge1xuICAgICAgbG9nLmluZm8oJ0RldmljZSBhbHJlYWR5IGhhZCByb290IGFjY2VzcycpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsb2cuaW5mbyhpc1N1Y2Nlc3NmdWwgPyAnUm9vdCBhY2Nlc3Mgc3VjY2Vzc2Z1bGx5IGdhaW5lZCcgOiAnQ291bGQgbm90IGdhaW4gcm9vdCBhY2Nlc3MnKTtcbiAgICB9XG4gIH1cbiAgbGV0IGRpZENvbW1hbmRGYWlsID0gZmFsc2U7XG4gIHRyeSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLmFkYkV4ZWMoXy5pc0FycmF5KGNtZCkgPyBbJ3NoZWxsJywgLi4uY21kXSA6IFsnc2hlbGwnLCBjbWRdLCBvcHRzKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGRpZENvbW1hbmRGYWlsID0gdHJ1ZTtcbiAgICAgIHRocm93IGVycjtcbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgLy8gUmV0dXJuIHRoZSAncm9vdCcgc3RhdGUgdG8gd2hhdCBpdCB3YXMgYmVmb3JlICdzaGVsbCcgd2FzIGNhbGxlZFxuICAgIGlmIChwcml2aWxlZ2VkICYmIHNob3VsZFJlc3RvcmVVc2VyICYmICgha2VlcFByaXZpbGVnZWQgfHwgZGlkQ29tbWFuZEZhaWwpKSB7XG4gICAgICBjb25zdCB7aXNTdWNjZXNzZnVsfSA9IGF3YWl0IHRoaXMudW5yb290KCk7XG4gICAgICBsb2cuZGVidWcoaXNTdWNjZXNzZnVsID8gJ1JldHVybmVkIGRldmljZSB0byB1bnJvb3RlZCBzdGF0ZScgOiAnQ291bGQgbm90IHJldHVybiBkZXZpY2UgdG8gdW5yb290ZWQgc3RhdGUnKTtcbiAgICB9XG4gIH1cbn07XG5cbnN5c3RlbUNhbGxNZXRob2RzLmNyZWF0ZVN1YlByb2Nlc3MgPSBmdW5jdGlvbiBjcmVhdGVTdWJQcm9jZXNzIChhcmdzID0gW10pIHtcbiAgLy8gYWRkIHRoZSBkZWZhdWx0IGFyZ3VtZW50c1xuICBhcmdzID0gdGhpcy5leGVjdXRhYmxlLmRlZmF1bHRBcmdzLmNvbmNhdChhcmdzKTtcbiAgbG9nLmRlYnVnKGBDcmVhdGluZyBBREIgc3VicHJvY2VzcyB3aXRoIGFyZ3M6ICR7SlNPTi5zdHJpbmdpZnkoYXJncyl9YCk7XG4gIHJldHVybiBuZXcgU3ViUHJvY2Vzcyh0aGlzLmdldEFkYlBhdGgoKSwgYXJncyk7XG59O1xuXG4vKipcbiAqIFJldHJpZXZlIHRoZSBjdXJyZW50IGFkYiBwb3J0LlxuICogQHRvZG8gY2FuIHByb2JhYmx5IGRlcHJlY2F0ZSB0aGlzIG5vdyB0aGF0IHRoZSBsb2dpYyBpcyBqdXN0IHRvIHJlYWQgdGhpcy5hZGJQb3J0XG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBjdXJyZW50IGFkYiBwb3J0IG51bWJlci5cbiAqL1xuc3lzdGVtQ2FsbE1ldGhvZHMuZ2V0QWRiU2VydmVyUG9ydCA9IGZ1bmN0aW9uIGdldEFkYlNlcnZlclBvcnQgKCkge1xuICByZXR1cm4gdGhpcy5hZGJQb3J0O1xufTtcblxuLyoqXG4gKiBSZXRyaWV2ZSB0aGUgY3VycmVudCBlbXVsYXRvciBwb3J0IGZyb20gX2FkYiBkZXZpdmVzXyBvdXRwdXQuXG4gKlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgY3VycmVudCBlbXVsYXRvciBwb3J0LlxuICogQHRocm93cyB7RXJyb3J9IElmIHRoZXJlIGFyZSBubyBjb25uZWN0ZWQgZGV2aWNlcy5cbiAqL1xuc3lzdGVtQ2FsbE1ldGhvZHMuZ2V0RW11bGF0b3JQb3J0ID0gYXN5bmMgZnVuY3Rpb24gZ2V0RW11bGF0b3JQb3J0ICgpIHtcbiAgbG9nLmRlYnVnKCdHZXR0aW5nIHJ1bm5pbmcgZW11bGF0b3IgcG9ydCcpO1xuICBpZiAodGhpcy5lbXVsYXRvclBvcnQgIT09IG51bGwpIHtcbiAgICByZXR1cm4gdGhpcy5lbXVsYXRvclBvcnQ7XG4gIH1cbiAgdHJ5IHtcbiAgICBsZXQgZGV2aWNlcyA9IGF3YWl0IHRoaXMuZ2V0Q29ubmVjdGVkRGV2aWNlcygpO1xuICAgIGxldCBwb3J0ID0gdGhpcy5nZXRQb3J0RnJvbUVtdWxhdG9yU3RyaW5nKGRldmljZXNbMF0udWRpZCk7XG4gICAgaWYgKHBvcnQpIHtcbiAgICAgIHJldHVybiBwb3J0O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEVtdWxhdG9yIHBvcnQgbm90IGZvdW5kYCk7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBObyBkZXZpY2VzIGNvbm5lY3RlZC4gT3JpZ2luYWwgZXJyb3I6ICR7ZS5tZXNzYWdlfWApO1xuICB9XG59O1xuXG4vKipcbiAqIFJldHJpZXZlIHRoZSBjdXJyZW50IGVtdWxhdG9yIHBvcnQgYnkgcGFyc2luZyBlbXVsYXRvciBuYW1lIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZW1TdHIgLSBFbXVsYXRvciBuYW1lIHN0cmluZy5cbiAqIEByZXR1cm4ge251bWJlcnxib29sZWFufSBFaXRoZXIgdGhlIGN1cnJlbnQgZW11bGF0b3IgcG9ydCBvclxuICogICAgICAgICAgICAgICAgICAgICAgICAgIF9mYWxzZV8gaWYgcG9ydCBudW1iZXIgY2Fubm90IGJlIHBhcnNlZC5cbiAqL1xuc3lzdGVtQ2FsbE1ldGhvZHMuZ2V0UG9ydEZyb21FbXVsYXRvclN0cmluZyA9IGZ1bmN0aW9uIGdldFBvcnRGcm9tRW11bGF0b3JTdHJpbmcgKGVtU3RyKSB7XG4gIGxldCBwb3J0UGF0dGVybiA9IC9lbXVsYXRvci0oXFxkKykvO1xuICBpZiAocG9ydFBhdHRlcm4udGVzdChlbVN0cikpIHtcbiAgICByZXR1cm4gcGFyc2VJbnQocG9ydFBhdHRlcm4uZXhlYyhlbVN0cilbMV0sIDEwKTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIFJldHJpZXZlIHRoZSBsaXN0IG9mIGN1cnJlbnRseSBjb25uZWN0ZWQgZW11bGF0b3JzLlxuICpcbiAqIEByZXR1cm4ge0FycmF5LjxEZXZpY2U+fSBUaGUgbGlzdCBvZiBjb25uZWN0ZWQgZGV2aWNlcy5cbiAqL1xuc3lzdGVtQ2FsbE1ldGhvZHMuZ2V0Q29ubmVjdGVkRW11bGF0b3JzID0gYXN5bmMgZnVuY3Rpb24gZ2V0Q29ubmVjdGVkRW11bGF0b3JzICgpIHtcbiAgbG9nLmRlYnVnKCdHZXR0aW5nIGNvbm5lY3RlZCBlbXVsYXRvcnMnKTtcbiAgdHJ5IHtcbiAgICBsZXQgZGV2aWNlcyA9IGF3YWl0IHRoaXMuZ2V0Q29ubmVjdGVkRGV2aWNlcygpO1xuICAgIGxldCBlbXVsYXRvcnMgPSBbXTtcbiAgICBmb3IgKGxldCBkZXZpY2Ugb2YgZGV2aWNlcykge1xuICAgICAgbGV0IHBvcnQgPSB0aGlzLmdldFBvcnRGcm9tRW11bGF0b3JTdHJpbmcoZGV2aWNlLnVkaWQpO1xuICAgICAgaWYgKHBvcnQpIHtcbiAgICAgICAgZGV2aWNlLnBvcnQgPSBwb3J0O1xuICAgICAgICBlbXVsYXRvcnMucHVzaChkZXZpY2UpO1xuICAgICAgfVxuICAgIH1cbiAgICBsb2cuZGVidWcoYCR7dXRpbC5wbHVyYWxpemUoJ2VtdWxhdG9yJywgZW11bGF0b3JzLmxlbmd0aCwgdHJ1ZSl9IGNvbm5lY3RlZGApO1xuICAgIHJldHVybiBlbXVsYXRvcnM7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm9yIGdldHRpbmcgZW11bGF0b3JzLiBPcmlnaW5hbCBlcnJvcjogJHtlLm1lc3NhZ2V9YCk7XG4gIH1cbn07XG5cbi8qKlxuICogU2V0IF9lbXVsYXRvclBvcnRfIHByb3BlcnR5IG9mIHRoZSBjdXJyZW50IGNsYXNzLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBlbVBvcnQgLSBUaGUgZW11bGF0b3IgcG9ydCB0byBiZSBzZXQuXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLnNldEVtdWxhdG9yUG9ydCA9IGZ1bmN0aW9uIHNldEVtdWxhdG9yUG9ydCAoZW1Qb3J0KSB7XG4gIHRoaXMuZW11bGF0b3JQb3J0ID0gZW1Qb3J0O1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIGlkZW50aWZpZXIgb2YgdGhlIGN1cnJlbnQgZGV2aWNlIChfdGhpcy5jdXJEZXZpY2VJZF8pLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSAtIFRoZSBkZXZpY2UgaWRlbnRpZmllci5cbiAqL1xuc3lzdGVtQ2FsbE1ldGhvZHMuc2V0RGV2aWNlSWQgPSBmdW5jdGlvbiBzZXREZXZpY2VJZCAoZGV2aWNlSWQpIHtcbiAgbG9nLmRlYnVnKGBTZXR0aW5nIGRldmljZSBpZCB0byAke2RldmljZUlkfWApO1xuICB0aGlzLmN1ckRldmljZUlkID0gZGV2aWNlSWQ7XG4gIGxldCBhcmdzSGFzRGV2aWNlID0gdGhpcy5leGVjdXRhYmxlLmRlZmF1bHRBcmdzLmluZGV4T2YoJy1zJyk7XG4gIGlmIChhcmdzSGFzRGV2aWNlICE9PSAtMSkge1xuICAgIC8vIHJlbW92ZSB0aGUgb2xkIGRldmljZSBpZCBmcm9tIHRoZSBhcmd1bWVudHNcbiAgICB0aGlzLmV4ZWN1dGFibGUuZGVmYXVsdEFyZ3Muc3BsaWNlKGFyZ3NIYXNEZXZpY2UsIDIpO1xuICB9XG4gIHRoaXMuZXhlY3V0YWJsZS5kZWZhdWx0QXJncy5wdXNoKCctcycsIGRldmljZUlkKTtcbn07XG5cbi8qKlxuICogU2V0IHRoZSB0aGUgY3VycmVudCBkZXZpY2Ugb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7RGV2aWNlfSBkZXZpY2VPYmogLSBUaGUgZGV2aWNlIG9iamVjdCB0byBiZSBzZXQuXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLnNldERldmljZSA9IGZ1bmN0aW9uIHNldERldmljZSAoZGV2aWNlT2JqKSB7XG4gIGxldCBkZXZpY2VJZCA9IGRldmljZU9iai51ZGlkO1xuICBsZXQgZW1Qb3J0ID0gdGhpcy5nZXRQb3J0RnJvbUVtdWxhdG9yU3RyaW5nKGRldmljZUlkKTtcbiAgdGhpcy5zZXRFbXVsYXRvclBvcnQoZW1Qb3J0KTtcbiAgdGhpcy5zZXREZXZpY2VJZChkZXZpY2VJZCk7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgb2JqZWN0IGZvciB0aGUgY3VycmVudGx5IHJ1bm5pbmcgZW11bGF0b3IuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGF2ZE5hbWUgLSBFbXVsYXRvciBuYW1lLlxuICogQHJldHVybiB7P0RldmljZX0gQ3VycmVudGx5IHJ1bm5pbmcgZW11bGF0b3Igb3IgX251bGxfLlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5nZXRSdW5uaW5nQVZEID0gYXN5bmMgZnVuY3Rpb24gZ2V0UnVubmluZ0FWRCAoYXZkTmFtZSkge1xuICBsb2cuZGVidWcoYFRyeWluZyB0byBmaW5kICcke2F2ZE5hbWV9JyBlbXVsYXRvcmApO1xuICB0cnkge1xuICAgIGNvbnN0IGVtdWxhdG9ycyA9IGF3YWl0IHRoaXMuZ2V0Q29ubmVjdGVkRW11bGF0b3JzKCk7XG4gICAgZm9yIChjb25zdCBlbXVsYXRvciBvZiBlbXVsYXRvcnMpIHtcbiAgICAgIHRoaXMuc2V0RW11bGF0b3JQb3J0KGVtdWxhdG9yLnBvcnQpO1xuICAgICAgY29uc3QgcnVubmluZ0FWRE5hbWUgPSBhd2FpdCB0aGlzLnNlbmRUZWxuZXRDb21tYW5kKCdhdmQgbmFtZScpO1xuICAgICAgaWYgKF8udG9Mb3dlcihhdmROYW1lKSA9PT0gXy50b0xvd2VyKHJ1bm5pbmdBVkROYW1lKSkge1xuICAgICAgICBsb2cuZGVidWcoYEZvdW5kIGVtdWxhdG9yICcke2F2ZE5hbWV9JyBvbiBwb3J0ICR7ZW11bGF0b3IucG9ydH1gKTtcbiAgICAgICAgdGhpcy5zZXREZXZpY2VJZChlbXVsYXRvci51ZGlkKTtcbiAgICAgICAgcmV0dXJuIGVtdWxhdG9yO1xuICAgICAgfVxuICAgIH1cbiAgICBsb2cuZGVidWcoYEVtdWxhdG9yICcke2F2ZE5hbWV9JyBub3QgcnVubmluZ2ApO1xuICAgIHJldHVybiBudWxsO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvciBnZXR0aW5nIEFWRC4gT3JpZ2luYWwgZXJyb3I6ICR7ZS5tZXNzYWdlfWApO1xuICB9XG59O1xuXG4vKipcbiAqIEdldCB0aGUgb2JqZWN0IGZvciB0aGUgY3VycmVudGx5IHJ1bm5pbmcgZW11bGF0b3IuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGF2ZE5hbWUgLSBFbXVsYXRvciBuYW1lLlxuICogQHBhcmFtIHtudW1iZXJ9IHRpbWVvdXRNcyBbMjAwMDBdIC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIG1pbGxpc2Vjb25kc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG8gd2FpdCB1bnRpbCBhdCBsZWFzdCBvbmUgcnVubmluZyBBVkQgb2JqZWN0XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpcyBkZXRlY3RlZC5cbiAqIEByZXR1cm4gez9EZXZpY2V9IEN1cnJlbnRseSBydW5uaW5nIGVtdWxhdG9yIG9yIF9udWxsXy5cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiBubyBkZXZpY2UgaGFzIGJlZW4gZGV0ZWN0ZWQgd2l0aGluIHRoZSB0aW1lb3V0LlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5nZXRSdW5uaW5nQVZEV2l0aFJldHJ5ID0gYXN5bmMgZnVuY3Rpb24gZ2V0UnVubmluZ0FWRFdpdGhSZXRyeSAoYXZkTmFtZSwgdGltZW91dE1zID0gMjAwMDApIHtcbiAgbGV0IHJ1bm5pbmdBdmQ7XG4gIHRyeSB7XG4gICAgYXdhaXQgd2FpdEZvckNvbmRpdGlvbihhc3luYyAoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBydW5uaW5nQXZkID0gYXdhaXQgdGhpcy5nZXRSdW5uaW5nQVZEKGF2ZE5hbWUucmVwbGFjZSgnQCcsICcnKSk7XG4gICAgICAgIHJldHVybiBydW5uaW5nQXZkO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBsb2cuZGVidWcoZS5tZXNzYWdlKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIHdhaXRNczogdGltZW91dE1zLFxuICAgICAgaW50ZXJ2YWxNczogMTAwMCxcbiAgICB9KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgRXJyb3IgZ2V0dGluZyBBVkQgd2l0aCByZXRyeS4gT3JpZ2luYWwgZXJyb3I6ICR7ZS5tZXNzYWdlfWApO1xuICB9XG4gIHJldHVybiBydW5uaW5nQXZkO1xufTtcblxuLyoqXG4gKiBTaHV0ZG93biBhbGwgcnVubmluZyBlbXVsYXRvcnMgYnkga2lsbGluZyB0aGVpciBwcm9jZXNzZXMuXG4gKlxuICogQHRocm93cyB7RXJyb3J9IElmIGtpbGxpbmcgdG9vbCByZXR1cm5lZCBub24temVybyByZXR1cm4gY29kZS5cbiAqL1xuc3lzdGVtQ2FsbE1ldGhvZHMua2lsbEFsbEVtdWxhdG9ycyA9IGFzeW5jIGZ1bmN0aW9uIGtpbGxBbGxFbXVsYXRvcnMgKCkge1xuICBsZXQgY21kLCBhcmdzO1xuICBpZiAoc3lzdGVtLmlzV2luZG93cygpKSB7XG4gICAgY21kID0gJ1RBU0tLSUxMJztcbiAgICBhcmdzID0gWydUQVNLS0lMTCcsICcvSU0nLCAnZW11bGF0b3IuZXhlJ107XG4gIH0gZWxzZSB7XG4gICAgY21kID0gJy91c3IvYmluL2tpbGxhbGwnO1xuICAgIGFyZ3MgPSBbJy1tJywgJ2VtdWxhdG9yKiddO1xuICB9XG4gIHRyeSB7XG4gICAgYXdhaXQgZXhlYyhjbWQsIGFyZ3MpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvciBraWxsaW5nIGVtdWxhdG9ycy4gT3JpZ2luYWwgZXJyb3I6ICR7ZS5tZXNzYWdlfWApO1xuICB9XG59O1xuXG4vKipcbiAqIEtpbGwgZW11bGF0b3Igd2l0aCB0aGUgZ2l2ZW4gbmFtZS4gTm8gZXJyb3JcbiAqIGlzIHRocm93biBpcyBnaXZlbiBhdmQgZG9lcyBub3QgZXhpc3QvaXMgbm90IHJ1bm5pbmcuXG4gKlxuICogQHBhcmFtIHs/c3RyaW5nfSBhdmROYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGVtdWxhdG9yIHRvIGJlIGtpbGxlZC4gSWYgZW1wdHksXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgY3VycmVudCBlbXVsYXRvciB3aWxsIGJlIGtpbGxlZC5cbiAqIEBwYXJhbSB7P251bWJlcn0gdGltZW91dCBbNjAwMDBdIC0gVGhlIGFtb3VudCBvZiB0aW1lIHRvIHdhaXQgYmVmb3JlIHRocm93aW5nXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuIGV4Y2VwdGlvbiBhYm91dCB1bnN1Y2Nlc3NmdWwga2lsbGluZ1xuICogQHJldHVybiB7Ym9vbGVhbn0gLSBUcnVlIGlmIHRoZSBlbXVsYXRvciB3YXMga2lsbGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gKiBAdGhyb3dzIHtFcnJvcn0gaWYgdGhlcmUgd2FzIGEgZmFpbHVyZSBieSBraWxsaW5nIHRoZSBlbXVsYXRvclxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5raWxsRW11bGF0b3IgPSBhc3luYyBmdW5jdGlvbiBraWxsRW11bGF0b3IgKGF2ZE5hbWUgPSBudWxsLCB0aW1lb3V0ID0gNjAwMDApIHtcbiAgaWYgKHV0aWwuaGFzVmFsdWUoYXZkTmFtZSkpIHtcbiAgICBsb2cuZGVidWcoYEtpbGxpbmcgYXZkICcke2F2ZE5hbWV9J2ApO1xuICAgIGNvbnN0IGRldmljZSA9IGF3YWl0IHRoaXMuZ2V0UnVubmluZ0FWRChhdmROYW1lKTtcbiAgICBpZiAoIWRldmljZSkge1xuICAgICAgbG9nLmluZm8oYE5vIGF2ZCB3aXRoIG5hbWUgJyR7YXZkTmFtZX0nIHJ1bm5pbmcuIFNraXBwaW5nIGtpbGwgc3RlcC5gKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8ga2lsbGluZyB0aGUgY3VycmVudCBhdmRcbiAgICBsb2cuZGVidWcoYEtpbGxpbmcgYXZkIHdpdGggaWQgJyR7dGhpcy5jdXJEZXZpY2VJZH0nYCk7XG4gICAgaWYgKCFhd2FpdCB0aGlzLmlzRW11bGF0b3JDb25uZWN0ZWQoKSkge1xuICAgICAgbG9nLmRlYnVnKGBFbXVsYXRvciB3aXRoIGlkICcke3RoaXMuY3VyRGV2aWNlSWR9JyBub3QgY29ubmVjdGVkLiBTa2lwcGluZyBraWxsIHN0ZXBgKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgYXdhaXQgdGhpcy5hZGJFeGVjKFsnZW11JywgJ2tpbGwnXSk7XG4gIGxvZy5kZWJ1ZyhgV2FpdGluZyB1cCB0byAke3RpbWVvdXR9bXMgdW50aWwgdGhlIGVtdWxhdG9yICcke2F2ZE5hbWUgPyBhdmROYW1lIDogdGhpcy5jdXJEZXZpY2VJZH0nIGlzIGtpbGxlZGApO1xuICB0cnkge1xuICAgIGF3YWl0IHdhaXRGb3JDb25kaXRpb24oYXN5bmMgKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHV0aWwuaGFzVmFsdWUoYXZkTmFtZSlcbiAgICAgICAgICA/ICFhd2FpdCB0aGlzLmdldFJ1bm5pbmdBVkQoYXZkTmFtZSlcbiAgICAgICAgICA6ICFhd2FpdCB0aGlzLmlzRW11bGF0b3JDb25uZWN0ZWQoKTtcbiAgICAgIH0gY2F0Y2ggKGlnbikge31cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LCB7XG4gICAgICB3YWl0TXM6IHRpbWVvdXQsXG4gICAgICBpbnRlcnZhbE1zOiAyMDAwLFxuICAgIH0pO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgZW11bGF0b3IgJyR7YXZkTmFtZSA/IGF2ZE5hbWUgOiB0aGlzLmN1ckRldmljZUlkfScgaXMgc3RpbGwgcnVubmluZyBhZnRlciBiZWluZyBraWxsZWQgJHt0aW1lb3V0fW1zIGFnb2ApO1xuICB9XG4gIGxvZy5pbmZvKGBTdWNjZXNzZnVsbHkga2lsbGVkIHRoZSAnJHthdmROYW1lID8gYXZkTmFtZSA6IHRoaXMuY3VyRGV2aWNlSWR9JyBlbXVsYXRvcmApO1xuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gQXZkTGF1bmNoT3B0aW9uc1xuICogQHByb3BlcnR5IHtzdHJpbmd8QXJyYXk8c3RyaW5nPn0gYXJncyBBZGRpdGlvbmFsIGVtdWxhdG9yIGNvbW1hbmQgbGluZSBhcmd1bWVudHNcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBlbnYgQWRkaXRpb25hbCBlbXVsYXRvciBlbnZpcm9ubWVudCB2YXJpYWJsZXNcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBsYW5ndWFnZSBFbXVsYXRvciBzeXN0ZW0gbGFuZ3VhZ2VcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBjb3VudHJ5IEVtdWxhdG9yIHN5c3RlbSBjb3VudHJ5XG4gKiBAcHJvcGVydHkge251bWJlcn0gbGF1bmNoVGltZW91dCBbNjAwMDBdIEVtdWxhdG9yIHN0YXJ0dXAgdGltZW91dCBpbiBtaWxsaXNlY29uZHNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSByZWFkeVRpbWVvdXQgWzYwMDAwXSBUaGUgbWF4aW11bSBwZXJpb2Qgb2YgdGltZSB0byB3YWl0IHVudGlsIEVtdWxhdG9yXG4gKiBpcyByZWFkeSBmb3IgdXNhZ2UgaW4gbWlsbGlzZWNvbmRzXG4gKiBAcHJvcGVydHkge251bWJlcn0gcmV0cnlUaW1lcyBbMV0gVGhlIG1heGltdW0gbnVtYmVyIG9mIHN0YXJ0dXAgcmV0cmllc1xuICovXG5cbi8qKlxuICogU3RhcnQgYW4gZW11bGF0b3Igd2l0aCBnaXZlbiBwYXJhbWV0ZXJzIGFuZCB3YWl0IHVudGlsIGl0IGlzIGZ1bGx5IHN0YXJ0ZWQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGF2ZE5hbWUgLSBUaGUgbmFtZSBvZiBhbiBleGlzdGluZyBlbXVsYXRvci5cbiAqIEBwYXJhbSB7P0F2ZExhdW5jaE9wdGlvbnN9IG9wdHNcbiAqIEByZXR1cm5zIHtTdWJQcm9jZXNzfSBFbXVsYXRvciBzdWJwcm9jZXNzIGluc3RhbmNlXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIGVtdWxhdG9yIGZhaWxzIHRvIHN0YXJ0IHdpdGhpbiB0aGUgZ2l2ZW4gdGltZW91dC5cbiAqL1xuc3lzdGVtQ2FsbE1ldGhvZHMubGF1bmNoQVZEID0gYXN5bmMgZnVuY3Rpb24gbGF1bmNoQVZEIChhdmROYW1lLCBvcHRzID0ge30pIHtcbiAgY29uc3Qge1xuICAgIGFyZ3MgPSBbXSxcbiAgICBlbnYgPSB7fSxcbiAgICBsYW5ndWFnZSxcbiAgICBjb3VudHJ5LFxuICAgIGxhdW5jaFRpbWVvdXQgPSA2MDAwMCxcbiAgICByZWFkeVRpbWVvdXQgPSA2MDAwMCxcbiAgICByZXRyeVRpbWVzID0gMSxcbiAgfSA9IG9wdHM7XG4gIGxvZy5kZWJ1ZyhgTGF1bmNoaW5nIEVtdWxhdG9yIHdpdGggQVZEICR7YXZkTmFtZX0sIGxhdW5jaFRpbWVvdXQgYCArXG4gICAgICAgICAgICBgJHtsYXVuY2hUaW1lb3V0fW1zIGFuZCByZWFkeVRpbWVvdXQgJHtyZWFkeVRpbWVvdXR9bXNgKTtcbiAgY29uc3QgZW11bGF0b3JCaW5hcnlQYXRoID0gYXdhaXQgdGhpcy5nZXRTZGtCaW5hcnlQYXRoKCdlbXVsYXRvcicpO1xuICBpZiAoYXZkTmFtZVswXSA9PT0gJ0AnKSB7XG4gICAgYXZkTmFtZSA9IGF2ZE5hbWUuc3Vic3RyKDEpO1xuICB9XG4gIGF3YWl0IHRoaXMuY2hlY2tBdmRFeGlzdChhdmROYW1lKTtcblxuICBjb25zdCBsYXVuY2hBcmdzID0gWyctYXZkJywgYXZkTmFtZV07XG4gIGxhdW5jaEFyZ3MucHVzaCguLi4odG9BdmRMb2NhbGVBcmdzKGxhbmd1YWdlLCBjb3VudHJ5KSkpO1xuICBpZiAoIV8uaXNFbXB0eShhcmdzKSkge1xuICAgIGxhdW5jaEFyZ3MucHVzaCguLi4oXy5pc0FycmF5KGFyZ3MpID8gYXJncyA6IHV0aWwuc2hlbGxQYXJzZShgJHthcmdzfWApKSk7XG4gIH1cbiAgbG9nLmRlYnVnKGBSdW5uaW5nICcke2VtdWxhdG9yQmluYXJ5UGF0aH0nIHdpdGggYXJnczogJHt1dGlsLnF1b3RlKGxhdW5jaEFyZ3MpfWApO1xuICBpZiAoIV8uaXNFbXB0eShlbnYpKSB7XG4gICAgbG9nLmRlYnVnKGBDdXN0b21pemVkIGVtdWxhdG9yIGVudmlyb25tZW50OiAke0pTT04uc3RyaW5naWZ5KGVudil9YCk7XG4gIH1cbiAgY29uc3QgcHJvYyA9IG5ldyBTdWJQcm9jZXNzKGVtdWxhdG9yQmluYXJ5UGF0aCwgbGF1bmNoQXJncywge1xuICAgIGVudjogT2JqZWN0LmFzc2lnbih7fSwgcHJvY2Vzcy5lbnYsIGVudiksXG4gIH0pO1xuICBhd2FpdCBwcm9jLnN0YXJ0KDApO1xuICBwcm9jLm9uKCdvdXRwdXQnLCAoc3Rkb3V0LCBzdGRlcnIpID0+IHtcbiAgICBmb3IgKGxldCBsaW5lIG9mIChzdGRvdXQgfHwgc3RkZXJyIHx8ICcnKS5zcGxpdCgnXFxuJykuZmlsdGVyKEJvb2xlYW4pKSB7XG4gICAgICBsb2cuaW5mbyhgW0FWRCBPVVRQVVRdICR7bGluZX1gKTtcbiAgICB9XG4gIH0pO1xuICBwcm9jLm9uKCdkaWUnLCAoY29kZSwgc2lnbmFsKSA9PiB7XG4gICAgbG9nLndhcm4oYEVtdWxhdG9yIGF2ZCAke2F2ZE5hbWV9IGV4aXRlZCB3aXRoIGNvZGUgJHtjb2RlfSR7c2lnbmFsID8gYCwgc2lnbmFsICR7c2lnbmFsfWAgOiAnJ31gKTtcbiAgfSk7XG4gIGF3YWl0IHJldHJ5KHJldHJ5VGltZXMsIGFzeW5jICgpID0+IGF3YWl0IHRoaXMuZ2V0UnVubmluZ0FWRFdpdGhSZXRyeShhdmROYW1lLCBsYXVuY2hUaW1lb3V0KSk7XG4gIGF3YWl0IHRoaXMud2FpdEZvckVtdWxhdG9yUmVhZHkocmVhZHlUaW1lb3V0KTtcbiAgcmV0dXJuIHByb2M7XG59O1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEFEQlZlcnNpb25cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB2ZXJzaW9uU3RyaW5nIC0gQURCIHZlcnNpb24gYXMgYSBzdHJpbmcuXG4gKiBAcHJvcGVydHkge2Zsb2F0fSB2ZXJzaW9uRmxvYXQgLSBWZXJzaW9uIG51bWJlciBhcyBmbG9hdCB2YWx1ZSAodXNlZnVsIGZvciBjb21wYXJpc29uKS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtYWpvciAtIE1ham9yIHZlcnNpb24gbnVtYmVyLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IG1pbm9yIC0gTWlub3IgdmVyc2lvbiBudW1iZXIuXG4gKiBAcHJvcGVydHkge251bWJlcn0gcGF0Y2ggLSBQYXRjaCB2ZXJzaW9uIG51bWJlci5cbiAqL1xuXG4vKipcbiAqIEdldCB0aGUgYWRiIHZlcnNpb24uIFRoZSByZXN1bHQgb2YgdGhpcyBtZXRob2QgaXMgY2FjaGVkLlxuICpcbiAqIEByZXR1cm4ge0FEQlZlcnNpb259IFRoZSBjdXJyZW50IGFkYiB2ZXJzaW9uLlxuICogQHRocm93cyB7RXJyb3J9IElmIGl0IGlzIG5vdCBwb3NzaWJsZSB0byBwYXJzZSBhZGIgdmVyc2lvbi5cbiAqL1xuc3lzdGVtQ2FsbE1ldGhvZHMuZ2V0QWRiVmVyc2lvbiA9IF8ubWVtb2l6ZShhc3luYyBmdW5jdGlvbiBnZXRBZGJWZXJzaW9uICgpIHtcbiAgdHJ5IHtcbiAgICBsZXQgYWRiVmVyc2lvbiA9IChhd2FpdCB0aGlzLmFkYkV4ZWMoJ3ZlcnNpb24nKSlcbiAgICAgIC5yZXBsYWNlKC9BbmRyb2lkXFxzRGVidWdcXHNCcmlkZ2VcXHN2ZXJzaW9uXFxzKFtcXGQuXSopW1xcc1xcdy1dKi8sICckMScpO1xuICAgIGxldCBwYXJ0cyA9IGFkYlZlcnNpb24uc3BsaXQoJy4nKTtcbiAgICByZXR1cm4ge1xuICAgICAgdmVyc2lvblN0cmluZzogYWRiVmVyc2lvbixcbiAgICAgIHZlcnNpb25GbG9hdDogcGFyc2VGbG9hdChhZGJWZXJzaW9uKSxcbiAgICAgIG1ham9yOiBwYXJzZUludChwYXJ0c1swXSwgMTApLFxuICAgICAgbWlub3I6IHBhcnNlSW50KHBhcnRzWzFdLCAxMCksXG4gICAgICBwYXRjaDogcGFydHNbMl0gPyBwYXJzZUludChwYXJ0c1syXSwgMTApIDogdW5kZWZpbmVkLFxuICAgIH07XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm9yIGdldHRpbmcgYWRiIHZlcnNpb24uIE9yaWdpbmFsIGVycm9yOiAnJHtlLm1lc3NhZ2V9JzsgYCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgU3RkZXJyOiAnJHsoZS5zdGRlcnIgfHwgJycpLnRyaW0oKX0nOyBDb2RlOiAnJHtlLmNvZGV9J2ApO1xuICB9XG59KTtcblxuLyoqXG4gKiBDaGVjayBpZiBnaXZlbiBlbXVsYXRvciBleGlzdHMgaW4gdGhlIGxpc3Qgb2YgYXZhaWxhYmxlIGF2ZHMuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGF2ZE5hbWUgLSBUaGUgbmFtZSBvZiBlbXVsYXRvciB0byB2ZXJpZnkgZm9yIGV4aXN0ZW5jZS5cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgZW11bGF0b3Igd2l0aCBnaXZlbiBuYW1lIGRvZXMgbm90IGV4aXN0LlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5jaGVja0F2ZEV4aXN0ID0gYXN5bmMgZnVuY3Rpb24gY2hlY2tBdmRFeGlzdCAoYXZkTmFtZSkge1xuICBsZXQgY21kLCByZXN1bHQ7XG4gIHRyeSB7XG4gICAgY21kID0gYXdhaXQgdGhpcy5nZXRTZGtCaW5hcnlQYXRoKCdlbXVsYXRvcicpO1xuICAgIHJlc3VsdCA9IGF3YWl0IGV4ZWMoY21kLCBbJy1saXN0LWF2ZHMnXSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBsZXQgdW5rbm93bk9wdGlvbkVycm9yID0gbmV3IFJlZ0V4cCgndW5rbm93biBvcHRpb246IC1saXN0LWF2ZHMnLCAnaScpLnRlc3QoZS5zdGRlcnIpO1xuICAgIGlmICghdW5rbm93bk9wdGlvbkVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm9yIGV4ZWN1dGluZyBjaGVja0F2ZEV4aXN0LiBPcmlnaW5hbCBlcnJvcjogJyR7ZS5tZXNzYWdlfSc7IGAgK1xuICAgICAgICAgICAgICAgICAgICAgIGBTdGRlcnI6ICckeyhlLnN0ZGVyciB8fCAnJykudHJpbSgpfSc7IENvZGU6ICcke2UuY29kZX0nYCk7XG5cbiAgICB9XG4gICAgY29uc3Qgc2RrVmVyc2lvbiA9IGF3YWl0IGdldFNka1Rvb2xzVmVyc2lvbigpO1xuICAgIGxldCBiaW5hcnlOYW1lID0gJ2FuZHJvaWQnO1xuICAgIGlmIChzZGtWZXJzaW9uKSB7XG4gICAgICBpZiAoc2RrVmVyc2lvbi5tYWpvciA+PSAyNSkge1xuICAgICAgICBiaW5hcnlOYW1lID0gJ2F2ZG1hbmFnZXInO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsb2cud2FybihgRGVmYXVsdGluZyBiaW5hcnkgbmFtZSB0byAnJHtiaW5hcnlOYW1lfScsIGJlY2F1c2UgU0RLIHZlcnNpb24gY2Fubm90IGJlIHBhcnNlZGApO1xuICAgIH1cbiAgICAvLyBJZiAtbGlzdC1hdmRzIG9wdGlvbiBpcyBub3QgYXZhaWxhYmxlLCB1c2UgYW5kcm9pZCBjb21tYW5kIGFzIGFuIGFsdGVybmF0aXZlXG4gICAgY21kID0gYXdhaXQgdGhpcy5nZXRTZGtCaW5hcnlQYXRoKGJpbmFyeU5hbWUpO1xuICAgIHJlc3VsdCA9IGF3YWl0IGV4ZWMoY21kLCBbJ2xpc3QnLCAnYXZkJywgJy1jJ10pO1xuICB9XG4gIGlmIChyZXN1bHQuc3Rkb3V0LmluZGV4T2YoYXZkTmFtZSkgPT09IC0xKSB7XG4gICAgbGV0IGV4aXN0aW5ncyA9IGAoJHtyZXN1bHQuc3Rkb3V0LnRyaW0oKS5yZXBsYWNlKC9bXFxuXS9nLCAnKSwgKCcpfSlgO1xuICAgIHRocm93IG5ldyBFcnJvcihgQXZkICcke2F2ZE5hbWV9JyBpcyBub3QgYXZhaWxhYmxlLiBwbGVhc2Ugc2VsZWN0IHlvdXIgYXZkIG5hbWUgZnJvbSBvbmUgb2YgdGhlc2U6ICcke2V4aXN0aW5nc30nYCk7XG4gIH1cbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGN1cnJlbnQgZW11bGF0b3IgaXMgcmVhZHkgdG8gYWNjZXB0IGZ1cnRoZXIgY29tbWFuZHMgKGJvb3RpbmcgY29tcGxldGVkKS5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gdGltZW91dE1zIFsyMDAwMF0gLSBUaGUgbWF4aW11bSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIHdhaXQuXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIGVtdWxhdG9yIGlzIG5vdCByZWFkeSB3aXRoaW4gdGhlIGdpdmVuIHRpbWVvdXQuXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLndhaXRGb3JFbXVsYXRvclJlYWR5ID0gYXN5bmMgZnVuY3Rpb24gd2FpdEZvckVtdWxhdG9yUmVhZHkgKHRpbWVvdXRNcyA9IDIwMDAwKSB7XG4gIHRyeSB7XG4gICAgYXdhaXQgd2FpdEZvckNvbmRpdGlvbihhc3luYyAoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoIShhd2FpdCB0aGlzLnNoZWxsKFsnZ2V0cHJvcCcsICdpbml0LnN2Yy5ib290YW5pbSddKSkuaW5jbHVkZXMoJ3N0b3BwZWQnKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTb21ldGltZXMgdGhlIHBhY2thZ2UgbWFuYWdlciBzZXJ2aWNlIG1pZ2h0IHN0aWxsIGJlaW5nIGluaXRpYWxpemVkXG4gICAgICAgIC8vIG9uIHNsb3cgc3lzdGVtcyBldmVuIGFmdGVyIGVtdWxhdG9yIGJvb3RpbmcgaXMgY29tcGxldGVkLlxuICAgICAgICAvLyBUaGUgdXN1YWwgb3V0cHV0IG9mIGBwbSBnZXQtaW5zdGFsbC1sb2NhdGlvbmAgY29tbWFuZCBsb29rcyBsaWtlIGAwW2F1dG9dYFxuICAgICAgICByZXR1cm4gL1xcZCtcXFtcXHcrXFxdLy50ZXN0KGF3YWl0IHRoaXMuc2hlbGwoWydwbScsICdnZXQtaW5zdGFsbC1sb2NhdGlvbiddKSk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgbG9nLmRlYnVnKGBXYWl0aW5nIGZvciBlbXVsYXRvciBzdGFydHVwLiBJbnRlcm1lZGlhdGUgZXJyb3I6ICR7ZXJyLm1lc3NhZ2V9YCk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICB3YWl0TXM6IHRpbWVvdXRNcyxcbiAgICAgIGludGVydmFsTXM6IDMwMDAsXG4gICAgfSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEVtdWxhdG9yIGlzIG5vdCByZWFkeSB3aXRoaW4gJHt0aW1lb3V0TXN9bXNgKTtcbiAgfVxufTtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgY3VycmVudCBkZXZpY2UgaXMgcmVhZHkgdG8gYWNjZXB0IGZ1cnRoZXIgY29tbWFuZHMgKGJvb3RpbmcgY29tcGxldGVkKS5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gYXBwRGV2aWNlUmVhZHlUaW1lb3V0IFszMF0gLSBUaGUgbWF4aW11bSBudW1iZXIgb2Ygc2Vjb25kcyB0byB3YWl0LlxuICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBkZXZpY2UgaXMgbm90IHJlYWR5IHdpdGhpbiB0aGUgZ2l2ZW4gdGltZW91dC5cbiAqL1xuc3lzdGVtQ2FsbE1ldGhvZHMud2FpdEZvckRldmljZSA9IGFzeW5jIGZ1bmN0aW9uIHdhaXRGb3JEZXZpY2UgKGFwcERldmljZVJlYWR5VGltZW91dCA9IDMwKSB7XG4gIHRoaXMuYXBwRGV2aWNlUmVhZHlUaW1lb3V0ID0gYXBwRGV2aWNlUmVhZHlUaW1lb3V0O1xuICBjb25zdCByZXRyaWVzID0gMztcbiAgY29uc3QgdGltZW91dCA9IHBhcnNlSW50KHRoaXMuYXBwRGV2aWNlUmVhZHlUaW1lb3V0LCAxMCkgLyByZXRyaWVzICogMTAwMDtcbiAgYXdhaXQgcmV0cnkocmV0cmllcywgYXN5bmMgKCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCB0aGlzLmFkYkV4ZWMoJ3dhaXQtZm9yLWRldmljZScsIHt0aW1lb3V0fSk7XG4gICAgICBhd2FpdCB0aGlzLnBpbmcoKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBhd2FpdCB0aGlzLnJlc3RhcnRBZGIoKTtcbiAgICAgIGF3YWl0IHRoaXMuZ2V0Q29ubmVjdGVkRGV2aWNlcygpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvciB3YWl0aW5nIGZvciB0aGUgZGV2aWNlIHRvIGJlIGF2YWlsYWJsZS4gT3JpZ2luYWwgZXJyb3I6ICcke2UubWVzc2FnZX0nYCk7XG4gICAgfVxuICB9KTtcbn07XG5cbi8qKlxuICogUmVib290IHRoZSBjdXJyZW50IGRldmljZSBhbmQgd2FpdCB1bnRpbCBpdCBpcyBjb21wbGV0ZWQuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IHJldHJpZXMgW0RFRkFVTFRfQURCX1JFQk9PVF9SRVRSSUVTXSAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiByZWJvb3QgcmV0cmllcy5cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgZGV2aWNlIGZhaWxlZCB0byByZWJvb3QgYW5kIG51bWJlciBvZiByZXRyaWVzIGlzIGV4Y2VlZGVkLlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5yZWJvb3QgPSBhc3luYyBmdW5jdGlvbiByZWJvb3QgKHJldHJpZXMgPSBERUZBVUxUX0FEQl9SRUJPT1RfUkVUUklFUykge1xuICAvLyBHZXQgcm9vdCBhY2Nlc3Mgc28gd2UgY2FuIHJ1biB0aGUgbmV4dCBzaGVsbCBjb21tYW5kcyB3aGljaCByZXF1aXJlIHJvb3QgYWNjZXNzXG4gIGNvbnN0IHsgd2FzQWxyZWFkeVJvb3RlZCB9ID0gYXdhaXQgdGhpcy5yb290KCk7XG4gIHRyeSB7XG4gICAgLy8gU3RvcCBhbmQgcmUtc3RhcnQgdGhlIGRldmljZVxuICAgIGF3YWl0IHRoaXMuc2hlbGwoWydzdG9wJ10pO1xuICAgIGF3YWl0IEIuZGVsYXkoMjAwMCk7IC8vIGxldCB0aGUgZW11IGZpbmlzaCBzdG9wcGluZztcbiAgICBhd2FpdCB0aGlzLnNldERldmljZVByb3BlcnR5KCdzeXMuYm9vdF9jb21wbGV0ZWQnLCAwLCB7XG4gICAgICBwcml2aWxlZ2VkOiBmYWxzZSAvLyBubyBuZWVkIHRvIHNldCBwcml2aWxlZ2VkIHRydWUgYmVjYXVzZSBkZXZpY2UgYWxyZWFkeSByb290ZWRcbiAgICB9KTtcbiAgICBhd2FpdCB0aGlzLnNoZWxsKFsnc3RhcnQnXSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBjb25zdCB7bWVzc2FnZX0gPSBlO1xuXG4gICAgLy8gcHJvdmlkZSBhIGhlbHBmdWwgZXJyb3IgbWVzc2FnZSBpZiB0aGUgcmVhc29uIHJlYm9vdCBmYWlsZWQgd2FzIGJlY2F1c2UgQURCIGNvdWxkbid0IGdhaW4gcm9vdCBhY2Nlc3NcbiAgICBpZiAobWVzc2FnZS5pbmNsdWRlcygnbXVzdCBiZSByb290JykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IHJlYm9vdCBkZXZpY2UuIFJlYm9vdGluZyByZXF1aXJlcyByb290IGFjY2VzcyBhbmQgYCArXG4gICAgICAgIGBhdHRlbXB0IHRvIGdldCByb290IGFjY2VzcyBvbiBkZXZpY2UgZmFpbGVkIHdpdGggZXJyb3I6ICcke21lc3NhZ2V9J2ApO1xuICAgIH1cbiAgICB0aHJvdyBlO1xuICB9IGZpbmFsbHkge1xuICAgIC8vIFJldHVybiByb290IHN0YXRlIHRvIHdoYXQgaXQgd2FzIGJlZm9yZVxuICAgIGlmICghd2FzQWxyZWFkeVJvb3RlZCkge1xuICAgICAgYXdhaXQgdGhpcy51bnJvb3QoKTtcbiAgICB9XG4gIH1cbiAgY29uc3QgdGltZXIgPSBuZXcgdGltaW5nLlRpbWVyKCkuc3RhcnQoKTtcbiAgYXdhaXQgcmV0cnlJbnRlcnZhbChyZXRyaWVzLCAxMDAwLCBhc3luYyAoKSA9PiB7XG4gICAgaWYgKChhd2FpdCB0aGlzLmdldERldmljZVByb3BlcnR5KCdzeXMuYm9vdF9jb21wbGV0ZWQnKSkgPT09ICcxJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyB3ZSBkb24ndCB3YW50IHRoZSBzdGFjayB0cmFjZSwgc28gbm8gbG9nLmVycm9yQW5kVGhyb3dcbiAgICBjb25zdCBtc2cgPSBgUmVib290IGlzIG5vdCBjb21wbGV0ZWQgYWZ0ZXIgJHt0aW1lci5nZXREdXJhdGlvbigpLmFzTWlsbGlTZWNvbmRzLnRvRml4ZWQoMCl9bXNgO1xuICAgIGxvZy5kZWJ1Zyhtc2cpO1xuICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICB9KTtcbn07XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gcm9vdFJlc3VsdFxuICogQHByb3BlcnR5IHtib29sZWFufSBpc1N1Y2Nlc3NmdWwgVHJ1ZSBpZiB0aGUgY2FsbCB0byByb290L3Vucm9vdCB3YXMgc3VjY2Vzc2Z1bFxuICogQHByb3BlcnR5IHtib29sZWFufSB3YXNBbHJlYWR5Um9vdGVkIFRydWUgaWYgdGhlIGRldmljZSB3YXMgYWxyZWFkeSByb290ZWRcbiAqL1xuXG4vKipcbiAqIFN3aXRjaCBhZGIgc2VydmVyIHJvb3QgcHJpdmlsZWdlcy5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNFbGV2YXRlZCAtIFNob3VsZCB3ZSBlbGV2YXRlIHRvIHRvIHJvb3Qgb3IgdW5yb290PyAoZGVmYXVsdCB0cnVlKVxuICogQHJldHVybiB7cm9vdFJlc3VsdH1cbiAqL1xuc3lzdGVtQ2FsbE1ldGhvZHMuY2hhbmdlVXNlclByaXZpbGVnZXMgPSBhc3luYyBmdW5jdGlvbiBjaGFuZ2VVc2VyUHJpdmlsZWdlcyAoaXNFbGV2YXRlZCkge1xuICBjb25zdCBjbWQgPSBpc0VsZXZhdGVkID8gJ3Jvb3QnIDogJ3Vucm9vdCc7XG5cbiAgLy8gSWYgaXQncyBhbHJlYWR5IHJvb3RlZCwgb3VyIGpvYiBpcyBkb25lLiBObyBuZWVkIHRvIHJvb3QgaXQgYWdhaW4uXG4gIGNvbnN0IGlzUm9vdCA9IGF3YWl0IHRoaXMuaXNSb290KCk7XG4gIGlmICgoaXNSb290ICYmIGlzRWxldmF0ZWQpIHx8ICghaXNSb290ICYmICFpc0VsZXZhdGVkKSkge1xuICAgIHJldHVybiB7aXNTdWNjZXNzZnVsOiB0cnVlLCB3YXNBbHJlYWR5Um9vdGVkOiBpc1Jvb3R9O1xuICB9XG5cbiAgbGV0IHdhc0FscmVhZHlSb290ZWQgPSBpc1Jvb3Q7XG4gIHRyeSB7XG4gICAgbGV0IHtzdGRvdXR9ID0gYXdhaXQgdGhpcy5hZGJFeGVjKFtjbWRdKTtcblxuICAgIC8vIG9uIHJlYWwgZGV2aWNlcyBpbiBzb21lIHNpdHVhdGlvbnMgd2UgZ2V0IGFuIGVycm9yIGluIHRoZSBzdGRvdXRcbiAgICBpZiAoc3Rkb3V0KSB7XG4gICAgICBpZiAoc3Rkb3V0LmluY2x1ZGVzKCdhZGJkIGNhbm5vdCBydW4gYXMgcm9vdCcpKSB7XG4gICAgICAgIHJldHVybiB7aXNTdWNjZXNzZnVsOiBmYWxzZSwgd2FzQWxyZWFkeVJvb3RlZH07XG4gICAgICB9XG4gICAgICAvLyBpZiB0aGUgZGV2aWNlIHdhcyBhbHJlYWR5IHJvb3RlZCwgcmV0dXJuIHRoYXQgaW4gdGhlIHJlc3VsdFxuICAgICAgaWYgKHN0ZG91dC5pbmNsdWRlcygnYWxyZWFkeSBydW5uaW5nIGFzIHJvb3QnKSkge1xuICAgICAgICB3YXNBbHJlYWR5Um9vdGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtpc1N1Y2Nlc3NmdWw6IHRydWUsIHdhc0FscmVhZHlSb290ZWR9O1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjb25zdCB7c3RkZXJyID0gJycsIG1lc3NhZ2V9ID0gZXJyO1xuICAgIGxvZy53YXJuKGBVbmFibGUgdG8gJHtjbWR9IGFkYiBkYWVtb24uIE9yaWdpbmFsIGVycm9yOiAnJHttZXNzYWdlfScuIFN0ZGVycjogJyR7c3RkZXJyfScuIENvbnRpbnVpbmcuYCk7XG5cbiAgICAvLyBDaGVjayB0aGUgb3V0cHV0IG9mIHRoZSBzdGRFcnIgdG8gc2VlIGlmIHRoZXJlJ3MgYW55IGNsdWVzIHRoYXQgc2hvdyB0aGF0IHRoZSBkZXZpY2Ugd2VudCBvZmZsaW5lXG4gICAgLy8gYW5kIGlmIGl0IGRpZCBnbyBvZmZsaW5lLCByZXN0YXJ0IEFEQlxuICAgIGlmIChbJ2Nsb3NlZCcsICdkZXZpY2Ugb2ZmbGluZScsICd0aW1lb3V0IGV4cGlyZWQnXS5zb21lKCh4KSA9PiBzdGRlcnIudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyh4KSkpIHtcbiAgICAgIGxvZy53YXJuKGBBdHRlbXB0IHRvICdhZGIgJHtjbWR9JyBjYXVzZWQgZGV2aWNlIHRvIGdvIG9mZmxpbmUuIFJlc3RhcnRpbmcgYWRiLmApO1xuICAgICAgYXdhaXQgdGhpcy5yZXN0YXJ0QWRiKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtpc1N1Y2Nlc3NmdWw6IGZhbHNlLCB3YXNBbHJlYWR5Um9vdGVkfTtcbiAgfVxufTtcblxuLyoqXG4gKiBTd2l0Y2ggYWRiIHNlcnZlciB0byByb290IG1vZGVcbiAqIEByZXR1cm4ge3Jvb3RSZXN1bHR9XG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLnJvb3QgPSBhc3luYyBmdW5jdGlvbiByb290ICgpIHtcbiAgcmV0dXJuIGF3YWl0IHRoaXMuY2hhbmdlVXNlclByaXZpbGVnZXModHJ1ZSk7XG59O1xuXG4vKipcbiAqIFN3aXRjaCBhZGIgc2VydmVyIHRvIG5vbi1yb290IG1vZGUuXG4gKlxuICogQHJldHVybiB7cm9vdFJlc3VsdH1cbiAqL1xuc3lzdGVtQ2FsbE1ldGhvZHMudW5yb290ID0gYXN5bmMgZnVuY3Rpb24gdW5yb290ICgpIHtcbiAgcmV0dXJuIGF3YWl0IHRoaXMuY2hhbmdlVXNlclByaXZpbGVnZXMoZmFsc2UpO1xufTtcblxuLyoqXG4gKiBDaGVja3Mgd2hldGhlciB0aGUgY3VycmVudCB1c2VyIGlzIHJvb3RcbiAqXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSB1c2VyIGlzIHJvb3RcbiAqIEB0aHJvd3Mge0Vycm9yfSBpZiB0aGVyZSB3YXMgYW4gZXJyb3Igd2hpbGUgaWRlbnRpZnlpbmdcbiAqIHRoZSB1c2VyLlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5pc1Jvb3QgPSBhc3luYyBmdW5jdGlvbiBpc1Jvb3QgKCkge1xuICByZXR1cm4gKGF3YWl0IHRoaXMuc2hlbGwoWyd3aG9hbWknXSkpLnRyaW0oKSA9PT0gJ3Jvb3QnO1xufTtcblxuLyoqXG4gKiBWZXJpZnkgd2hldGhlciBhIHJlbW90ZSBwYXRoIGV4aXN0cyBvbiB0aGUgZGV2aWNlIHVuZGVyIHRlc3QuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHJlbW90ZVBhdGggLSBUaGUgcmVtb3RlIHBhdGggdG8gdmVyaWZ5LlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgZ2l2ZW4gcGF0aCBleGlzdHMgb24gdGhlIGRldmljZS5cbiAqL1xuc3lzdGVtQ2FsbE1ldGhvZHMuZmlsZUV4aXN0cyA9IGFzeW5jIGZ1bmN0aW9uIGZpbGVFeGlzdHMgKHJlbW90ZVBhdGgpIHtcbiAgY29uc3QgcGFzc0ZsYWcgPSAnX19QQVNTX18nO1xuICBjb25zdCBjaGVja0NtZCA9IGBbIC1lICcke3JlbW90ZVBhdGgucmVwbGFjZSgvJy9nLCBgXFxcXCdgKX0nIF0gJiYgZWNobyAke3Bhc3NGbGFnfWA7XG4gIHRyeSB7XG4gICAgcmV0dXJuIF8uaW5jbHVkZXMoYXdhaXQgdGhpcy5zaGVsbChbY2hlY2tDbWRdKSwgcGFzc0ZsYWcpO1xuICB9IGNhdGNoIChpZ24pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbi8qKlxuICogR2V0IHRoZSBvdXRwdXQgb2YgX2xzXyBjb21tYW5kIG9uIHRoZSBkZXZpY2UgdW5kZXIgdGVzdC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVtb3RlUGF0aCAtIFRoZSByZW1vdGUgcGF0aCAodGhlIGZpcnN0IGFyZ3VtZW50IHRvIHRoZSBfbHNfIGNvbW1hbmQpLlxuICogQHBhcmFtIHtBcnJheS48U3RyaW5nPn0gb3B0cyBbW11dIC0gQWRkaXRpb25hbCBfbHNfIG9wdGlvbnMuXG4gKiBAcmV0dXJuIHtBcnJheS48U3RyaW5nPn0gVGhlIF9sc18gb3V0cHV0IGFzIGFuIGFycmF5IG9mIHNwbGl0IGxpbmVzLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgIEFuIGVtcHR5IGFycmF5IGlzIHJldHVybmVkIG9mIHRoZSBnaXZlbiBfcmVtb3RlUGF0aF9cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICBkb2VzIG5vdCBleGlzdC5cbiAqL1xuc3lzdGVtQ2FsbE1ldGhvZHMubHMgPSBhc3luYyBmdW5jdGlvbiBscyAocmVtb3RlUGF0aCwgb3B0cyA9IFtdKSB7XG4gIHRyeSB7XG4gICAgbGV0IGFyZ3MgPSBbJ2xzJywgLi4ub3B0cywgcmVtb3RlUGF0aF07XG4gICAgbGV0IHN0ZG91dCA9IGF3YWl0IHRoaXMuc2hlbGwoYXJncyk7XG4gICAgbGV0IGxpbmVzID0gc3Rkb3V0LnNwbGl0KCdcXG4nKTtcbiAgICByZXR1cm4gbGluZXMubWFwKChsKSA9PiBsLnRyaW0oKSlcbiAgICAgIC5maWx0ZXIoQm9vbGVhbilcbiAgICAgIC5maWx0ZXIoKGwpID0+IGwuaW5kZXhPZignTm8gc3VjaCBmaWxlJykgPT09IC0xKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgaWYgKGVyci5tZXNzYWdlLmluZGV4T2YoJ05vIHN1Y2ggZmlsZSBvciBkaXJlY3RvcnknKSA9PT0gLTEpIHtcbiAgICAgIHRocm93IGVycjtcbiAgICB9XG4gICAgcmV0dXJuIFtdO1xuICB9XG59O1xuXG4vKipcbiAqIEdldCB0aGUgc2l6ZSBvZiB0aGUgcGFydGljdWxhciBmaWxlIGxvY2F0ZWQgb24gdGhlIGRldmljZSB1bmRlciB0ZXN0LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSByZW1vdGVQYXRoIC0gVGhlIHJlbW90ZSBwYXRoIHRvIHRoZSBmaWxlLlxuICogQHJldHVybiB7bnVtYmVyfSBGaWxlIHNpemUgaW4gYnl0ZXMuXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlcmUgd2FzIGFuIGVycm9yIHdoaWxlIGdldHRpbmcgdGhlIHNpemUgb2YgdGhlIGdpdmVuIGZpbGUuXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLmZpbGVTaXplID0gYXN5bmMgZnVuY3Rpb24gZmlsZVNpemUgKHJlbW90ZVBhdGgpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBmaWxlcyA9IGF3YWl0IHRoaXMubHMocmVtb3RlUGF0aCwgWyctbGEnXSk7XG4gICAgaWYgKGZpbGVzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBSZW1vdGUgcGF0aCBpcyBub3QgYSBmaWxlYCk7XG4gICAgfVxuICAgIC8vIGh0dHBzOi8vcmVnZXgxMDEuY29tL3IvZk9zNFA0LzhcbiAgICBjb25zdCBtYXRjaCA9IC9bcnd4c1N0VFxcLStdezEwfVtcXHNcXGRdKlxcc1teXFxzXStcXHMrW15cXHNdK1xccysoXFxkKykvLmV4ZWMoZmlsZXNbMF0pO1xuICAgIGlmICghbWF0Y2ggfHwgXy5pc05hTihwYXJzZUludChtYXRjaFsxXSwgMTApKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gcGFyc2Ugc2l6ZSBmcm9tIGxpc3Qgb3V0cHV0OiAnJHtmaWxlc1swXX0nYCk7XG4gICAgfVxuICAgIHJldHVybiBwYXJzZUludChtYXRjaFsxXSwgMTApO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byBnZXQgZmlsZSBzaXplIGZvciAnJHtyZW1vdGVQYXRofSc6ICR7ZXJyLm1lc3NhZ2V9YCk7XG4gIH1cbn07XG5cbi8qKlxuICogSW5zdGFsbHMgdGhlIGdpdmVuIGNlcnRpZmljYXRlIG9uIGEgcm9vdGVkIHJlYWwgZGV2aWNlIG9yXG4gKiBhbiBlbXVsYXRvci4gVGhlIGVtdWxhdG9yIG11c3QgYmUgZXhlY3V0ZWQgd2l0aCBgLXdyaXRhYmxlLXN5c3RlbWBcbiAqIGNvbW1hbmQgbGluZSBvcHRpb24gYW5kIGFkYiBkYWVtb24gc2hvdWxkIGJlIHJ1bm5pbmcgaW4gcm9vdFxuICogbW9kZSBmb3IgdGhpcyBtZXRob2QgdG8gd29yayBwcm9wZXJseS4gVGhlIG1ldGhvZCBhbHNvIHJlcXVpcmVzXG4gKiBvcGVuc3NsIHRvb2wgdG8gYmUgYXZhaWxhYmxlIG9uIHRoZSBkZXN0aW5hdGlvbiBzeXN0ZW0uXG4gKiBSZWFkIGh0dHBzOi8vZ2l0aHViLmNvbS9hcHBpdW0vYXBwaXVtL2lzc3Vlcy8xMDk2NFxuICogZm9yIG1vcmUgZGV0YWlscyBvbiB0aGlzIHRvcGljXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ8c3RyaW5nfSBjZXJ0IC0gYmFzZTY0LWRlY29kZWQgY29udGVudCBvZiB0aGUgYWN0dWFsIGNlcnRpZmljYXRlXG4gKiByZXByZXNlbnRlZCBhcyBhIHN0cmluZyBvciBhIGJ1ZmZlclxuICogQHRocm93cyB7RXJyb3J9IElmIG9wZW5zc2wgdG9vbCBpcyBub3QgYXZhaWxhYmxlIG9uIHRoZSBkZXN0aW5hdGlvbiBzeXN0ZW1cbiAqIG9yIGlmIHRoZXJlIHdhcyBhbiBlcnJvciB3aGlsZSBpbnN0YWxsaW5nIHRoZSBjZXJ0aWZpY2F0ZVxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5pbnN0YWxsTWl0bUNlcnRpZmljYXRlID0gYXN5bmMgZnVuY3Rpb24gaW5zdGFsbE1pdG1DZXJ0aWZpY2F0ZSAoY2VydCkge1xuICBjb25zdCBvcGVuU3NsID0gYXdhaXQgZ2V0T3BlblNzbEZvck9zKCk7XG5cbiAgaWYgKCFfLmlzQnVmZmVyKGNlcnQpKSB7XG4gICAgY2VydCA9IEJ1ZmZlci5mcm9tKGNlcnQsICdiYXNlNjQnKTtcbiAgfVxuXG4gIGNvbnN0IHRtcFJvb3QgPSBhd2FpdCB0ZW1wRGlyLm9wZW5EaXIoKTtcbiAgdHJ5IHtcbiAgICBjb25zdCBzcmNDZXJ0ID0gcGF0aC5yZXNvbHZlKHRtcFJvb3QsICdzb3VyY2UuY2VyJyk7XG4gICAgYXdhaXQgZnMud3JpdGVGaWxlKHNyY0NlcnQsIGNlcnQpO1xuICAgIGxldCB7c3Rkb3V0fSA9IGF3YWl0IGV4ZWMob3BlblNzbCwgWyd4NTA5JywgJy1ub291dCcsICctaGFzaCcsICctaW4nLCBzcmNDZXJ0XSk7XG4gICAgY29uc3QgY2VydEhhc2ggPSBzdGRvdXQudHJpbSgpO1xuICAgIGxvZy5kZWJ1ZyhgR290IGNlcnRpZmljYXRlIGhhc2g6ICR7Y2VydEhhc2h9YCk7XG4gICAgbG9nLmRlYnVnKCdQcmVwYXJpbmcgY2VydGlmaWNhdGUgY29udGVudCcpO1xuICAgICh7c3Rkb3V0fSA9IGF3YWl0IGV4ZWMob3BlblNzbCwgWyd4NTA5JywgJy1pbicsIHNyY0NlcnRdLCB7aXNCdWZmZXI6IHRydWV9KSk7XG4gICAgbGV0IGRzdENlcnRDb250ZW50ID0gc3Rkb3V0O1xuICAgICh7c3Rkb3V0fSA9IGF3YWl0IGV4ZWMob3BlblNzbCwgWyd4NTA5JyxcbiAgICAgICctaW4nLCBzcmNDZXJ0LFxuICAgICAgJy10ZXh0JyxcbiAgICAgICctZmluZ2VycHJpbnQnLFxuICAgICAgJy1ub291dCddLCB7aXNCdWZmZXI6IHRydWV9KSk7XG4gICAgZHN0Q2VydENvbnRlbnQgPSBCdWZmZXIuY29uY2F0KFtkc3RDZXJ0Q29udGVudCwgc3Rkb3V0XSk7XG4gICAgY29uc3QgZHN0Q2VydCA9IHBhdGgucmVzb2x2ZSh0bXBSb290LCBgJHtjZXJ0SGFzaH0uMGApO1xuICAgIGF3YWl0IGZzLndyaXRlRmlsZShkc3RDZXJ0LCBkc3RDZXJ0Q29udGVudCk7XG4gICAgbG9nLmRlYnVnKCdSZW1vdW50aW5nIC9zeXN0ZW0gaW4gcncgbW9kZScpO1xuICAgIC8vIFNvbWV0aW1lcyBlbXVsYXRvciByZWJvb3QgaXMgc3RpbGwgbm90IGZ1bGx5IGZpbmlzaGVkIG9uIHRoaXMgc3RhZ2UsIHNvIHJldHJ5XG4gICAgYXdhaXQgcmV0cnlJbnRlcnZhbCg1LCAyMDAwLCBhc3luYyAoKSA9PiBhd2FpdCB0aGlzLmFkYkV4ZWMoWydyZW1vdW50J10pKTtcbiAgICBsb2cuZGVidWcoYFVwbG9hZGluZyB0aGUgZ2VuZXJhdGVkIGNlcnRpZmljYXRlIGZyb20gJyR7ZHN0Q2VydH0nIHRvICcke0NFUlRTX1JPT1R9J2ApO1xuICAgIGF3YWl0IHRoaXMucHVzaChkc3RDZXJ0LCBDRVJUU19ST09UKTtcbiAgICBsb2cuZGVidWcoJ1JlbW91bnRpbmcgL3N5c3RlbSB0byBjb25maXJtIGNoYW5nZXMnKTtcbiAgICBhd2FpdCB0aGlzLmFkYkV4ZWMoWydyZW1vdW50J10pO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBpbmplY3QgdGhlIGN1c3RvbSBjZXJ0aWZpY2F0ZS4gYCArXG4gICAgICAgICAgICAgICAgICAgIGBJcyB0aGUgY2VydGlmaWNhdGUgcHJvcGVybHkgZW5jb2RlZCBpbnRvIGJhc2U2NC1zdHJpbmc/IGAgK1xuICAgICAgICAgICAgICAgICAgICBgRG8geW91IGhhdmUgcm9vdCBwZXJtaXNzaW9ucyBvbiB0aGUgZGV2aWNlPyBgICtcbiAgICAgICAgICAgICAgICAgICAgYE9yaWdpbmFsIGVycm9yOiAke2Vyci5tZXNzYWdlfWApO1xuICB9IGZpbmFsbHkge1xuICAgIGF3YWl0IGZzLnJpbXJhZih0bXBSb290KTtcbiAgfVxufTtcblxuLyoqXG4gKiBWZXJpZmllcyBpZiB0aGUgZ2l2ZW4gcm9vdCBjZXJ0aWZpY2F0ZSBpcyBhbHJlYWR5IGluc3RhbGxlZCBvbiB0aGUgZGV2aWNlLlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfHN0cmluZ30gY2VydCAtIGJhc2U2NC1kZWNvZGVkIGNvbnRlbnQgb2YgdGhlIGFjdHVhbCBjZXJ0aWZpY2F0ZVxuICogcmVwcmVzZW50ZWQgYXMgYSBzdHJpbmcgb3IgYSBidWZmZXJcbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiBvcGVuc3NsIHRvb2wgaXMgbm90IGF2YWlsYWJsZSBvbiB0aGUgZGVzdGluYXRpb24gc3lzdGVtXG4gKiBvciBpZiB0aGVyZSB3YXMgYW4gZXJyb3Igd2hpbGUgY2hlY2tpbmcgdGhlIGNlcnRpZmljYXRlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgZ2l2ZW4gY2VydGlmaWNhdGUgaXMgYWxyZWFkeSBpbnN0YWxsZWRcbiAqL1xuc3lzdGVtQ2FsbE1ldGhvZHMuaXNNaXRtQ2VydGlmaWNhdGVJbnN0YWxsZWQgPSBhc3luYyBmdW5jdGlvbiBpc01pdG1DZXJ0aWZpY2F0ZUluc3RhbGxlZCAoY2VydCkge1xuICBjb25zdCBvcGVuU3NsID0gYXdhaXQgZ2V0T3BlblNzbEZvck9zKCk7XG5cbiAgaWYgKCFfLmlzQnVmZmVyKGNlcnQpKSB7XG4gICAgY2VydCA9IEJ1ZmZlci5mcm9tKGNlcnQsICdiYXNlNjQnKTtcbiAgfVxuXG4gIGNvbnN0IHRtcFJvb3QgPSBhd2FpdCB0ZW1wRGlyLm9wZW5EaXIoKTtcbiAgbGV0IGNlcnRIYXNoO1xuICB0cnkge1xuICAgIGNvbnN0IHRtcENlcnQgPSBwYXRoLnJlc29sdmUodG1wUm9vdCwgJ3NvdXJjZS5jZXInKTtcbiAgICBhd2FpdCBmcy53cml0ZUZpbGUodG1wQ2VydCwgY2VydCk7XG4gICAgY29uc3Qge3N0ZG91dH0gPSBhd2FpdCBleGVjKG9wZW5Tc2wsIFsneDUwOScsICctbm9vdXQnLCAnLWhhc2gnLCAnLWluJywgdG1wQ2VydF0pO1xuICAgIGNlcnRIYXNoID0gc3Rkb3V0LnRyaW0oKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgcmV0cmlldmUgdGhlIGNlcnRpZmljYXRlIGhhc2guIGAgK1xuICAgICAgICAgICAgICAgICAgICBgSXMgdGhlIGNlcnRpZmljYXRlIHByb3Blcmx5IGVuY29kZWQgaW50byBiYXNlNjQtc3RyaW5nPyBgICtcbiAgICAgICAgICAgICAgICAgICAgYE9yaWdpbmFsIGVycm9yOiAke2Vyci5tZXNzYWdlfWApO1xuICB9IGZpbmFsbHkge1xuICAgIGF3YWl0IGZzLnJpbXJhZih0bXBSb290KTtcbiAgfVxuICBjb25zdCBkc3RQYXRoID0gcGF0aC5wb3NpeC5yZXNvbHZlKENFUlRTX1JPT1QsIGAke2NlcnRIYXNofS4wYCk7XG4gIGxvZy5kZWJ1ZyhgQ2hlY2tpbmcgaWYgdGhlIGNlcnRpZmljYXRlIGlzIGFscmVhZHkgaW5zdGFsbGVkIGF0ICcke2RzdFBhdGh9J2ApO1xuICByZXR1cm4gYXdhaXQgdGhpcy5maWxlRXhpc3RzKGRzdFBhdGgpO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgc3lzdGVtQ2FsbE1ldGhvZHM7XG5leHBvcnQgeyBERUZBVUxUX0FEQl9FWEVDX1RJTUVPVVQgfTtcbiJdLCJmaWxlIjoibGliL3Rvb2xzL3N5c3RlbS1jYWxscy5qcyIsInNvdXJjZVJvb3QiOiIuLi8uLi8uLiJ9
